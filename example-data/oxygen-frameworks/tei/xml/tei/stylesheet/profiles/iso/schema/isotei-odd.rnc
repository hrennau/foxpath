default namespace = "http://www.lisa.org/TBX-Specification.33.0.html"
namespace a = "http://relaxng.org/ns/compatibility/annotations/1.0"
namespace i = "http://www.iso.org/ns/1.0"
namespace ns1 = "http://www.w3.org/1998/Math/MathML"
namespace ns10 = "http://schemas.openxmlformats.org/drawingml/2006/main"
namespace ns11 = "http://www.tei-c.org/ns/Examples"
namespace ns12 = "http://www.example.org/ns/nonTEI"
namespace ns2 =
  "http://schemas.openxmlformats.org/wordprocessingml/2006/main"
namespace ns3 = "http://www.tei-c.org/ns/teidocx/1.0"
namespace ns4 = "urn:schemas-microsoft-com:office:office"
namespace ns5 = "http://www.oasis-open.org/specs/tm9901"
namespace ns6 = "http://www.tei-c.org/ns/1.0"
namespace ns7 =
  "http://schemas.openxmlformats.org/drawingml/2006/picture"
namespace ns8 = "urn:schemas-microsoft-com:vml"
namespace ns9 =
  "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing"
namespace rng = "http://relaxng.org/ns/structure/1.0"
namespace s = "http://www.ascc.net/xml/schematron"
namespace sch = "http://purl.oclc.org/dsdl/schematron"
namespace xi = "http://www.w3.org/2001/XInclude"
namespace xlink = "http://www.w3.org/1999/xlink"

# Schema generated from ODD source 2010-06-04T15:06:00Z. 
# Edition: 1.6.0 (June 2010)
#

#
div {
  extrapattern = anyDoc?, pattern, anyDoc?
  pattern =
    element rng:element {
      attribute name { xsd:QName },
      extrapattern+,
      attribute ns { xsd:anyURI }?
    }
    | element rng:element { nameClass, extrapattern+ }
    | element rng:attribute {
        attribute name { xsd:QName },
        attribute ns { xsd:anyURI }?,
        anyAttDoc?,
        extrapattern?
      }
    | element rng:attribute { nameClass, extrapattern? }
    | element rng:group { extrapattern+ }
    | element rng:interleave { extrapattern+ }
    | element rng:choice { extrapattern+ }
    | element rng:optional { extrapattern+ }
    | element rng:zeroOrMore { extrapattern+ }
    | element rng:oneOrMore { extrapattern+ }
    | element rng:list { extrapattern+ }
    | element rng:mixed { extrapattern+ }
    | element rng:ref {
        attribute name { xsd:NCName }
      }
    | element rng:parentRef {
        attribute name { xsd:NCName }
      }
    | element rng:empty { empty }
    | element rng:text { empty }
    | element rng:value {
        attribute type { xsd:NCName }?,
        xsd:string
      }
    | element rng:data {
        attribute type { xsd:NCName },
        param*,
        exceptExtrapattern?
      }
    | element rng:notAllowed { empty }
    | element rng:externalRef {
        attribute href { xsd:anyURI },
        empty
      }
    | element rng:grammar {
        attribute datatypeLibrary { xsd:anyURI }?,
        attribute ns { xsd:anyURI },
        grammarContent*
      }
  anyDoc =
    element a:* {
      attribute ns { xsd:anyURI }?,
      (anyDoc | text)*
    }
  anyAttDoc = attribute a:defaultValue { text }
  param =
    element rng:param {
      attribute name { xsd:NCName },
      xsd:string
    }
  exceptExtrapattern = element rng:except { extrapattern+ }
  grammarContent =
    \start
    | define
    | element rng:div { grammarContent* }
    | element rng:include {
        attribute href { xsd:anyURI },
        includeContent*
      }
  includeContent =
    \start
    | define
    | element rng:div { includeContent* }
  \start =
    element rng:start {
      attribute combine { method }?,
      extrapattern
    }
  define =
    element rng:define {
      attribute name { xsd:NCName },
      attribute combine { method }?,
      extrapattern+
    }
  method = "choice" | "interleave"
  nameClass =
    element rng:name { xsd:QName }
    | element rng:anyName { exceptNameClass? }
    | element rng:nsName {
        attribute ns { xsd:anyURI }?,
        exceptNameClass?
      }
    | element rng:choice { nameClass+ }
  exceptNameClass = element rng:except { nameClass+ }
}
div {
  div {
    math_XLINK.xmlns.attrib = empty
    MATHML.xmlns.extra.attrib = math_XLINK.xmlns.attrib
    MATHML.xmlns.attrib = empty, MATHML.xmlns.extra.attrib
  }
  MATHML.NamespaceDecl.attrib = MATHML.xmlns.attrib
  MATHML.Common.attrib =
    MATHML.NamespaceDecl.attrib,
    attribute xlink:href { text }?,
    attribute xlink:type { text }?,
    attribute class { text }?,
    attribute style { text }?,
    attribute id { xsd:ID }?,
    attribute xref { xsd:IDREF }?,
    attribute other { text }?
  mathml.att-fontsize = attribute fontsize { text }?
  mathml.att-fontweight = attribute fontweight { "normal" | "bold" }?
  mathml.att-fontstyle = attribute fontstyle { "normal" | "italic" }?
  mathml.att-fontfamily = attribute fontfamily { text }?
  mathml.att-color = attribute color { text }?
  mathml.att-mathvariant = attribute mathvariant { text }?
  mathml.att-mathsize = attribute mathsize { text }?
  mathml.att-mathcolor = attribute mathcolor { text }?
  mathml.att-mathbackground = attribute mathbackground { text }?
  mathml.att-fontinfo =
    mathml.att-fontsize,
    mathml.att-fontweight,
    mathml.att-fontstyle,
    mathml.att-fontfamily,
    mathml.att-color,
    mathml.att-mathvariant,
    mathml.att-mathsize,
    mathml.att-mathcolor,
    mathml.att-mathbackground
  mathml.att-form = attribute form { "prefix" | "infix" | "postfix" }?
  mathml.att-fence = attribute fence { "true" | "false" }?
  mathml.att-separator = attribute separator { "true" | "false" }?
  mathml.att-lspace = attribute lspace { text }?
  mathml.att-rspace = attribute rspace { text }?
  mathml.att-stretchy = attribute stretchy { "true" | "false" }?
  mathml.att-symmetric = attribute symmetric { "true" | "false" }?
  mathml.att-maxsize = attribute maxsize { text }?
  mathml.att-minsize = attribute minsize { text }?
  mathml.att-largeop = attribute largeop { "true" | "false" }?
  mathml.att-movablelimits =
    attribute movablelimits { "true" | "false" }?
  mathml.att-accent = attribute accent { "true" | "false" }?
  mathml.att-opinfo =
    mathml.att-form,
    mathml.att-fence,
    mathml.att-separator,
    mathml.att-lspace,
    mathml.att-rspace,
    mathml.att-stretchy,
    mathml.att-symmetric,
    mathml.att-maxsize,
    mathml.att-minsize,
    mathml.att-largeop,
    mathml.att-movablelimits,
    mathml.att-accent
  mathml.att-width = attribute width { text }?
  mathml.att-height = attribute height { text }?
  mathml.att-depth = attribute depth { text }?
  mathml.att-linebreak = attribute linebreak { text }?
  mathml.att-sizeinfo =
    mathml.att-width, mathml.att-height, mathml.att-depth
  mathml.att-lquote = attribute lquote { text }?
  mathml.att-rquote = attribute rquote { text }?
  mathml.att-linethickness = attribute linethickness { text }?
  mathml.att-scriptlevel = attribute scriptlevel { text }?
  mathml.att-displaystyle = attribute displaystyle { "true" | "false" }?
  mathml.att-scriptsizemultiplier =
    attribute scriptsizemultiplier { text }?
  mathml.att-scriptminsize = attribute scriptminsize { text }?
  mathml.att-background = attribute background { text }?
  mathml.att-veryverythinmathspace =
    attribute veryverythinmathspace { text }?
  mathml.att-verythinmathspace = attribute verythinmathspace { text }?
  mathml.att-thinmathspace = attribute thinmathspace { text }?
  mathml.att-mediummathspace = attribute mediummathspace { text }?
  mathml.att-thickmathspace = attribute thickmathspace { text }?
  mathml.att-verythickmathspace = attribute verythickmathspace { text }?
  mathml.att-veryverythickmathspace =
    attribute veryverythickmathspace { text }?
  mathml.att-open = attribute open { text }?
  mathml.att-close = attribute close { text }?
  mathml.att-separators = attribute separators { text }?
  mathml.att-subscriptshift = attribute subscriptshift { text }?
  mathml.att-superscriptshift = attribute superscriptshift { text }?
  mathml.att-accentunder = attribute accentunder { "true" | "false" }?
  mathml.att-align = attribute align { text }?
  mathml.att-numalign = attribute numalign { text }?
  mathml.att-denomalign = attribute denomalign { text }?
  mathml.att-rowalign = attribute rowalign { text }?
  mathml.att-columnalign = attribute columnalign { text }?
  mathml.att-columnwidth = attribute columnwidth { text }?
  mathml.att-groupalign = attribute groupalign { text }?
  mathml.att-alignmentscope = attribute alignmentscope { text }?
  mathml.att-rowspacing = attribute rowspacing { text }?
  mathml.att-columnspacing = attribute columnspacing { text }?
  mathml.att-rowlines = attribute rowlines { text }?
  mathml.att-columnlines = attribute columnlines { text }?
  mathml.att-frame = attribute frame { "none" | "solid" | "dashed" }?
  mathml.att-side =
    attribute side {
      "left" | "right" | "leftoverlap" | "rightoverlap"
    }?
  mathml.att-framespacing = attribute framespacing { text }?
  mathml.att-equalrows = attribute equalrows { text }?
  mathml.att-equalcolumns = attribute equalcolumns { text }?
  mathml.att-tableinfo =
    mathml.att-align,
    mathml.att-rowalign,
    mathml.att-columnalign,
    mathml.att-columnwidth,
    mathml.att-groupalign,
    mathml.att-alignmentscope,
    mathml.att-side,
    mathml.att-rowspacing,
    mathml.att-columnspacing,
    mathml.att-rowlines,
    mathml.att-columnlines,
    mathml.att-width,
    mathml.att-frame,
    mathml.att-framespacing,
    mathml.att-equalrows,
    mathml.att-equalcolumns,
    mathml.att-displaystyle
  mathml.att-rowspan = attribute rowspan { text }?
  mathml.att-columnspan = attribute columnspan { text }?
  mathml.att-edge = attribute edge { "left" | "right" }?
  mathml.att-actiontype = attribute actiontype { text }?
  mathml.att-selection = attribute selection { text }?
  mathml.att-name = attribute name { text }?
  mathml.att-alt = attribute alt { text }?
  mathml.att-index = attribute index { text }?
  mathml.att-bevelled = attribute bevelled { text }?
  mathml.ptoken =
    mathml.mi | mathml.mn | mathml.mo | mathml.mtext | mathml.ms
  mathml.attlist-mi &= MATHML.Common.attrib, mathml.att-fontinfo
  mathml.attlist-mn &= MATHML.Common.attrib, mathml.att-fontinfo
  mathml.attlist-mo &=
    MATHML.Common.attrib, mathml.att-fontinfo, mathml.att-opinfo
  mathml.attlist-mtext &= MATHML.Common.attrib, mathml.att-fontinfo
  mathml.attlist-ms &=
    MATHML.Common.attrib,
    mathml.att-fontinfo,
    mathml.att-lquote,
    mathml.att-rquote
  mathml.petoken = mathml.mspace
  mathml.mspace = element ns1:mspace { mathml.attlist-mspace, empty }
  mathml.any |= mathml.mspace
  mathml.attlist-mspace &=
    mathml.att-sizeinfo, mathml.att-linebreak, MATHML.Common.attrib
  mathml.pgenschema =
    mathml.mrow
    | mathml.mfrac
    | mathml.msqrt
    | mathml.mroot
    | mathml.menclose
    | mathml.mstyle
    | mathml.merror
    | mathml.mpadded
    | mathml.mphantom
    | mathml.mfenced
  mathml.attlist-mrow &= MATHML.Common.attrib
  mathml.attlist-mfrac &=
    MATHML.Common.attrib,
    mathml.att-bevelled,
    mathml.att-numalign,
    mathml.att-denomalign,
    mathml.att-linethickness
  mathml.attlist-msqrt &= MATHML.Common.attrib
  mathml.attlist-menclose &=
    MATHML.Common.attrib,
    [ a:defaultValue = "longdiv" ] attribute notation { text }?
  mathml.attlist-mroot &= MATHML.Common.attrib
  mathml.attlist-mstyle &=
    MATHML.Common.attrib,
    mathml.att-fontinfo,
    mathml.att-opinfo,
    mathml.att-lquote,
    mathml.att-rquote,
    mathml.att-linethickness,
    mathml.att-scriptlevel,
    mathml.att-scriptsizemultiplier,
    mathml.att-scriptminsize,
    mathml.att-background,
    mathml.att-veryverythinmathspace,
    mathml.att-verythinmathspace,
    mathml.att-thinmathspace,
    mathml.att-mediummathspace,
    mathml.att-thickmathspace,
    mathml.att-verythickmathspace,
    mathml.att-veryverythickmathspace,
    mathml.att-open,
    mathml.att-close,
    mathml.att-separators,
    mathml.att-subscriptshift,
    mathml.att-superscriptshift,
    mathml.att-accentunder,
    mathml.att-tableinfo,
    mathml.att-rowspan,
    mathml.att-columnspan,
    mathml.att-edge,
    mathml.att-actiontype,
    mathml.att-selection
  mathml.attlist-merror &= MATHML.Common.attrib
  mathml.attlist-mpadded &=
    MATHML.Common.attrib, mathml.att-sizeinfo, mathml.att-lspace
  mathml.attlist-mphantom &= MATHML.Common.attrib
  mathml.attlist-mfenced &=
    MATHML.Common.attrib,
    mathml.att-open,
    mathml.att-close,
    mathml.att-separators
  mathml.pscrschema =
    mathml.msub
    | mathml.msup
    | mathml.msubsup
    | mathml.munder
    | mathml.mover
    | mathml.munderover
    | mathml.mmultiscripts
  mathml.attlist-msub &= MATHML.Common.attrib, mathml.att-subscriptshift
  mathml.attlist-msup &=
    MATHML.Common.attrib, mathml.att-superscriptshift
  mathml.attlist-msubsup &=
    MATHML.Common.attrib,
    mathml.att-subscriptshift,
    mathml.att-superscriptshift
  mathml.attlist-munder &= MATHML.Common.attrib, mathml.att-accentunder
  mathml.attlist-mover &= MATHML.Common.attrib, mathml.att-accent
  mathml.attlist-munderover &=
    MATHML.Common.attrib, mathml.att-accent, mathml.att-accentunder
  mathml.attlist-mmultiscripts &=
    MATHML.Common.attrib,
    mathml.att-subscriptshift,
    mathml.att-superscriptshift
  mathml.pscreschema = mathml.mprescripts | mathml.none
  mathml.mprescripts =
    element ns1:mprescripts { mathml.attlist-mprescripts, empty }
  mathml.any |= mathml.mprescripts
  mathml.attlist-mprescripts &= MATHML.xmlns.attrib
  mathml.none = element ns1:none { mathml.attlist-none, empty }
  mathml.any |= mathml.none
  mathml.attlist-none &= MATHML.xmlns.attrib
  mathml.ptabschema =
    mathml.mtable | mathml.mtr | mathml.mlabeledtr | mathml.mtd
  mathml.attlist-mtable &= MATHML.Common.attrib, mathml.att-tableinfo
  mathml.attlist-mtr &=
    MATHML.Common.attrib,
    mathml.att-rowalign,
    mathml.att-columnalign,
    mathml.att-groupalign
  mathml.attlist-mlabeledtr &=
    MATHML.Common.attrib,
    mathml.att-rowalign,
    mathml.att-columnalign,
    mathml.att-groupalign
  mathml.attlist-mtd &=
    MATHML.Common.attrib,
    mathml.att-rowalign,
    mathml.att-columnalign,
    mathml.att-groupalign,
    mathml.att-rowspan,
    mathml.att-columnspan
  mathml.plschema =
    mathml.pgenschema | mathml.pscrschema | mathml.ptabschema
  mathml.peschema = mathml.maligngroup | mathml.malignmark
  mathml.malignmark =
    element ns1:malignmark { mathml.attlist-malignmark, empty }
  mathml.any |= mathml.malignmark
  mathml.attlist-malignmark &= mathml.att-edge
  mathml.maligngroup =
    element ns1:maligngroup { mathml.attlist-maligngroup, empty }
  mathml.any |= mathml.maligngroup
  mathml.attlist-maligngroup &=
    MATHML.Common.attrib, mathml.att-groupalign
  mathml.mglyph = element ns1:mglyph { mathml.attlist-mglyph, empty }
  mathml.any |= mathml.mglyph
  mathml.attlist-mglyph &=
    mathml.att-alt, mathml.att-fontfamily, mathml.att-index
  mathml.pactions = mathml.maction
  mathml.attlist-maction &=
    MATHML.Common.attrib, mathml.att-actiontype, mathml.att-selection
  mathml.PresInCont =
    mathml.ptoken
    | mathml.petoken
    | mathml.plschema
    | mathml.peschema
    | mathml.pactions
  mathml.Presentation =
    mathml.ptoken
    | mathml.petoken
    | mathml.pscreschema
    | mathml.plschema
    | mathml.peschema
    | mathml.pactions
  mathml.att-base = [ a:defaultValue = "10" ] attribute base { text }?
  mathml.att-closure =
    [ a:defaultValue = "closed" ] attribute closure { text }?
  mathml.att-definition =
    [ a:defaultValue = "" ] attribute definitionURL { text }?
  mathml.att-encoding =
    [ a:defaultValue = "" ] attribute encoding { text }?
  mathml.att-nargs = [ a:defaultValue = "1" ] attribute nargs { text }?
  mathml.att-occurrence =
    [ a:defaultValue = "function-model" ] attribute occurrence { text }?
  mathml.att-order =
    [ a:defaultValue = "numeric" ] attribute order { text }?
  mathml.att-scope =
    [ a:defaultValue = "local" ] attribute scope { text }?
  mathml.att-type = attribute type { text }?
  mathml.ctoken = mathml.csymbol | mathml.ci | mathml.cn
  mathml.attlist-ci &=
    MATHML.Common.attrib,
    mathml.att-type,
    mathml.att-definition,
    mathml.att-encoding
  mathml.attlist-csymbol &=
    MATHML.Common.attrib,
    mathml.att-encoding,
    mathml.att-type,
    mathml.att-definition
  mathml.attlist-cn &=
    MATHML.Common.attrib,
    mathml.att-type,
    mathml.att-base,
    mathml.att-definition,
    mathml.att-encoding
  mathml.cspecial = mathml.apply | mathml.reln | mathml.lambda
  mathml.attlist-apply &= MATHML.Common.attrib
  mathml.attlist-reln &= MATHML.Common.attrib
  mathml.attlist-lambda &= MATHML.Common.attrib
  mathml.cother = mathml.condition | mathml.declare | mathml.sep
  mathml.attlist-condition &= MATHML.Common.attrib
  mathml.attlist-declare &=
    MATHML.Common.attrib,
    mathml.att-type,
    mathml.att-scope,
    mathml.att-nargs,
    mathml.att-occurrence,
    mathml.att-definition,
    mathml.att-encoding
  mathml.sep = element ns1:sep { mathml.attlist-sep, empty }
  mathml.any |= mathml.sep
  mathml.attlist-sep &= MATHML.xmlns.attrib
  mathml.csemantics =
    mathml.semantics | mathml.annotation | mathml.annotation-xml
  mathml.attlist-semantics &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.attlist-annotation &= MATHML.Common.attrib, mathml.att-encoding
  mathml.attlist-annotation-xml &=
    MATHML.Common.attrib, mathml.att-encoding
  mathml.cconstructor =
    mathml.interval
    | mathml.list
    | mathml.matrix
    | mathml.matrixrow
    | mathml.set
    | mathml.vector
    | mathml.piecewise
  mathml.attlist-interval &= MATHML.Common.attrib, mathml.att-closure
  mathml.attlist-set &= MATHML.Common.attrib, mathml.att-type
  mathml.attlist-list &= MATHML.Common.attrib, mathml.att-order
  mathml.attlist-vector &= MATHML.Common.attrib
  mathml.attlist-matrix &= MATHML.Common.attrib
  mathml.attlist-matrixrow &= MATHML.Common.attrib
  mathml.attlist-piecewise &= MATHML.Common.attrib
  mathml.attlist-piece &= MATHML.Common.attrib
  mathml.attlist-otherwise &= MATHML.Common.attrib
  mathml.c0ary =
    mathml.integers
    | mathml.reals
    | mathml.rationals
    | mathml.naturalnumbers
    | mathml.complexes
    | mathml.primes
    | mathml.exponentiale
    | mathml.imaginaryi
    | mathml.notanumber
    | mathml.true
    | mathml.false
    | mathml.emptyset
    | mathml.pi
    | mathml.eulergamma
    | mathml.infinity
  mathml.integers =
    element ns1:integers { mathml.attlist-integers, empty }
  mathml.any |= mathml.integers
  mathml.attlist-integers &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.reals = element ns1:reals { mathml.attlist-reals, empty }
  mathml.any |= mathml.reals
  mathml.attlist-reals &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.rationals =
    element ns1:rationals { mathml.attlist-rationals, empty }
  mathml.any |= mathml.rationals
  mathml.attlist-rationals &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.naturalnumbers =
    element ns1:naturalnumbers { mathml.attlist-naturalnumbers, empty }
  mathml.any |= mathml.naturalnumbers
  mathml.attlist-naturalnumbers &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.complexes =
    element ns1:complexes { mathml.attlist-complexes, empty }
  mathml.any |= mathml.complexes
  mathml.attlist-complexes &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.primes = element ns1:primes { mathml.attlist-primes, empty }
  mathml.any |= mathml.primes
  mathml.attlist-primes &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.exponentiale =
    element ns1:exponentiale { mathml.attlist-exponentiale, empty }
  mathml.any |= mathml.exponentiale
  mathml.attlist-exponentiale &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.imaginaryi =
    element ns1:imaginaryi { mathml.attlist-imaginaryi, empty }
  mathml.any |= mathml.imaginaryi
  mathml.attlist-imaginaryi &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.notanumber =
    element ns1:notanumber { mathml.attlist-notanumber, empty }
  mathml.any |= mathml.notanumber
  mathml.attlist-notanumber &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.true = element ns1:true { mathml.attlist-true, empty }
  mathml.any |= mathml.true
  mathml.attlist-true &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.false = element ns1:false { mathml.attlist-false, empty }
  mathml.any |= mathml.false
  mathml.attlist-false &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.emptyset =
    element ns1:emptyset { mathml.attlist-emptyset, empty }
  mathml.any |= mathml.emptyset
  mathml.attlist-emptyset &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.pi = element ns1:pi { mathml.attlist-pi, empty }
  mathml.any |= mathml.pi
  mathml.attlist-pi &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.eulergamma =
    element ns1:eulergamma { mathml.attlist-eulergamma, empty }
  mathml.any |= mathml.eulergamma
  mathml.attlist-eulergamma &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.infinity =
    element ns1:infinity { mathml.attlist-infinity, empty }
  mathml.any |= mathml.infinity
  mathml.attlist-infinity &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.cfuncop1ary =
    mathml.inverse
    | mathml.ident
    | mathml.domain
    | mathml.codomain
    | mathml.image
  mathml.inverse = element ns1:inverse { mathml.attlist-inverse, empty }
  mathml.any |= mathml.inverse
  mathml.attlist-inverse &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.domain = element ns1:domain { mathml.attlist-domain, empty }
  mathml.any |= mathml.domain
  mathml.attlist-domain &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.codomain =
    element ns1:codomain { mathml.attlist-codomain, empty }
  mathml.any |= mathml.codomain
  mathml.attlist-codomain &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.image = element ns1:image { mathml.attlist-image, empty }
  mathml.any |= mathml.image
  mathml.attlist-image &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.cfuncopnary = mathml.fn | mathml.compose
  mathml.attlist-fn &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.ident = element ns1:ident { mathml.attlist-ident, empty }
  mathml.any |= mathml.ident
  mathml.attlist-ident &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.compose = element ns1:compose { mathml.attlist-compose, empty }
  mathml.any |= mathml.compose
  mathml.attlist-compose &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.carithop1ary =
    mathml.abs
    | mathml.conjugate
    | mathml.exp
    | mathml.factorial
    | mathml.arg
    | mathml.real
    | mathml.imaginary
    | mathml.floor
    | mathml.ceiling
  mathml.exp = element ns1:exp { mathml.attlist-exp, empty }
  mathml.any |= mathml.exp
  mathml.attlist-exp &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.abs = element ns1:abs { mathml.attlist-abs, empty }
  mathml.any |= mathml.abs
  mathml.attlist-abs &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.arg = element ns1:arg { mathml.attlist-arg, empty }
  mathml.any |= mathml.arg
  mathml.attlist-arg &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.real = element ns1:real { mathml.attlist-real, empty }
  mathml.any |= mathml.real
  mathml.attlist-real &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.imaginary =
    element ns1:imaginary { mathml.attlist-imaginary, empty }
  mathml.any |= mathml.imaginary
  mathml.attlist-imaginary &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.conjugate =
    element ns1:conjugate { mathml.attlist-conjugate, empty }
  mathml.any |= mathml.conjugate
  mathml.attlist-conjugate &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.factorial =
    element ns1:factorial { mathml.attlist-factorial, empty }
  mathml.any |= mathml.factorial
  mathml.attlist-factorial &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.floor = element ns1:floor { mathml.attlist-floor, empty }
  mathml.any |= mathml.floor
  mathml.attlist-floor &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.ceiling = element ns1:ceiling { mathml.attlist-ceiling, empty }
  mathml.any |= mathml.ceiling
  mathml.attlist-ceiling &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.carithop1or2ary = mathml.minus
  mathml.minus = element ns1:minus { mathml.attlist-minus, empty }
  mathml.any |= mathml.minus
  mathml.attlist-minus &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.carithop2ary =
    mathml.quotient | mathml.divide | mathml.power | mathml.rem
  mathml.quotient =
    element ns1:quotient { mathml.attlist-quotient, empty }
  mathml.any |= mathml.quotient
  mathml.attlist-quotient &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.divide = element ns1:divide { mathml.attlist-divide, empty }
  mathml.any |= mathml.divide
  mathml.attlist-divide &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.power = element ns1:power { mathml.attlist-power, empty }
  mathml.any |= mathml.power
  mathml.attlist-power &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.rem = element ns1:rem { mathml.attlist-rem, empty }
  mathml.any |= mathml.rem
  mathml.attlist-rem &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.carithopnary =
    mathml.plus
    | mathml.times
    | mathml.max
    | mathml.min
    | mathml.gcd
    | mathml.lcm
  mathml.plus = element ns1:plus { mathml.attlist-plus, empty }
  mathml.any |= mathml.plus
  mathml.attlist-plus &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.max = element ns1:max { mathml.attlist-max, empty }
  mathml.any |= mathml.max
  mathml.attlist-max &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.min = element ns1:min { mathml.attlist-min, empty }
  mathml.any |= mathml.min
  mathml.attlist-min &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.times = element ns1:times { mathml.attlist-times, empty }
  mathml.any |= mathml.times
  mathml.attlist-times &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.gcd = element ns1:gcd { mathml.attlist-gcd, empty }
  mathml.any |= mathml.gcd
  mathml.attlist-gcd &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.lcm = element ns1:lcm { mathml.attlist-lcm, empty }
  mathml.any |= mathml.lcm
  mathml.attlist-lcm &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.carithoproot = mathml.root
  mathml.root = element ns1:root { mathml.attlist-root, empty }
  mathml.any |= mathml.root
  mathml.attlist-root &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.clogicopquant = mathml.exists | mathml.forall
  mathml.exists = element ns1:exists { mathml.attlist-exists, empty }
  mathml.any |= mathml.exists
  mathml.attlist-exists &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.forall = element ns1:forall { mathml.attlist-forall, empty }
  mathml.any |= mathml.forall
  mathml.attlist-forall &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.clogicopnary = mathml.and | mathml.or | mathml.xor
  mathml.and = element ns1:and { mathml.attlist-and, empty }
  mathml.any |= mathml.and
  mathml.attlist-and &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.or = element ns1:or { mathml.attlist-or, empty }
  mathml.any |= mathml.or
  mathml.attlist-or &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.xor = element ns1:xor { mathml.attlist-xor, empty }
  mathml.any |= mathml.xor
  mathml.attlist-xor &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.clogicop1ary = mathml.not
  mathml.not = element ns1:not { mathml.attlist-not, empty }
  mathml.any |= mathml.not
  mathml.attlist-not &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.clogicop2ary = mathml.implies
  mathml.implies = element ns1:implies { mathml.attlist-implies, empty }
  mathml.any |= mathml.implies
  mathml.attlist-implies &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.ccalcop =
    mathml.log
    | mathml.int
    | mathml.diff
    | mathml.partialdiff
    | mathml.divergence
    | mathml.grad
    | mathml.curl
    | mathml.laplacian
  mathml.divergence =
    element ns1:divergence { mathml.attlist-divergence, empty }
  mathml.any |= mathml.divergence
  mathml.attlist-divergence &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.grad = element ns1:grad { mathml.attlist-grad, empty }
  mathml.any |= mathml.grad
  mathml.attlist-grad &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.curl = element ns1:curl { mathml.attlist-curl, empty }
  mathml.any |= mathml.curl
  mathml.attlist-curl &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.laplacian =
    element ns1:laplacian { mathml.attlist-laplacian, empty }
  mathml.any |= mathml.laplacian
  mathml.attlist-laplacian &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.log = element ns1:log { mathml.attlist-log, empty }
  mathml.any |= mathml.log
  mathml.attlist-log &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.int = element ns1:int { mathml.attlist-int, empty }
  mathml.any |= mathml.int
  mathml.attlist-int &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.diff = element ns1:diff { mathml.attlist-diff, empty }
  mathml.any |= mathml.diff
  mathml.attlist-diff &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.partialdiff =
    element ns1:partialdiff { mathml.attlist-partialdiff, empty }
  mathml.any |= mathml.partialdiff
  mathml.attlist-partialdiff &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.ccalcop1ary = mathml.ln
  mathml.ln = element ns1:ln { mathml.attlist-ln, empty }
  mathml.any |= mathml.ln
  mathml.attlist-ln &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.csetop1ary = mathml.card
  mathml.card = element ns1:card { mathml.attlist-card, empty }
  mathml.any |= mathml.card
  mathml.attlist-card &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.csetop2ary = mathml.setdiff
  mathml.setdiff = element ns1:setdiff { mathml.attlist-setdiff, empty }
  mathml.any |= mathml.setdiff
  mathml.attlist-setdiff &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.csetopnary =
    mathml.union | mathml.intersect | mathml.cartesianproduct
  mathml.union = element ns1:union { mathml.attlist-union, empty }
  mathml.any |= mathml.union
  mathml.attlist-union &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.intersect =
    element ns1:intersect { mathml.attlist-intersect, empty }
  mathml.any |= mathml.intersect
  mathml.attlist-intersect &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.cartesianproduct =
    element ns1:cartesianproduct {
      mathml.attlist-cartesianproduct, empty
    }
  mathml.any |= mathml.cartesianproduct
  mathml.attlist-cartesianproduct &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.cseqop = mathml.sum | mathml.product | mathml.limit
  mathml.sum = element ns1:sum { mathml.attlist-sum, empty }
  mathml.any |= mathml.sum
  mathml.attlist-sum &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.product = element ns1:product { mathml.attlist-product, empty }
  mathml.any |= mathml.product
  mathml.attlist-product &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.limit = element ns1:limit { mathml.attlist-limit, empty }
  mathml.any |= mathml.limit
  mathml.attlist-limit &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.ctrigop =
    mathml.sin
    | mathml.cos
    | mathml.tan
    | mathml.sec
    | mathml.csc
    | mathml.cot
    | mathml.sinh
    | mathml.cosh
    | mathml.tanh
    | mathml.sech
    | mathml.csch
    | mathml.coth
    | mathml.arcsin
    | mathml.arccos
    | mathml.arctan
    | mathml.arccosh
    | mathml.arccot
    | mathml.arccoth
    | mathml.arccsc
    | mathml.arccsch
    | mathml.arcsec
    | mathml.arcsech
    | mathml.arcsinh
    | mathml.arctanh
  mathml.sin = element ns1:sin { mathml.attlist-sin, empty }
  mathml.any |= mathml.sin
  mathml.attlist-sin &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.cos = element ns1:cos { mathml.attlist-cos, empty }
  mathml.any |= mathml.cos
  mathml.attlist-cos &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.tan = element ns1:tan { mathml.attlist-tan, empty }
  mathml.any |= mathml.tan
  mathml.attlist-tan &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.sec = element ns1:sec { mathml.attlist-sec, empty }
  mathml.any |= mathml.sec
  mathml.attlist-sec &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.csc = element ns1:csc { mathml.attlist-csc, empty }
  mathml.any |= mathml.csc
  mathml.attlist-csc &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.cot = element ns1:cot { mathml.attlist-cot, empty }
  mathml.any |= mathml.cot
  mathml.attlist-cot &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.sinh = element ns1:sinh { mathml.attlist-sinh, empty }
  mathml.any |= mathml.sinh
  mathml.attlist-sinh &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.cosh = element ns1:cosh { mathml.attlist-cosh, empty }
  mathml.any |= mathml.cosh
  mathml.attlist-cosh &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.tanh = element ns1:tanh { mathml.attlist-tanh, empty }
  mathml.any |= mathml.tanh
  mathml.attlist-tanh &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.sech = element ns1:sech { mathml.attlist-sech, empty }
  mathml.any |= mathml.sech
  mathml.attlist-sech &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.csch = element ns1:csch { mathml.attlist-csch, empty }
  mathml.any |= mathml.csch
  mathml.attlist-csch &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.coth = element ns1:coth { mathml.attlist-coth, empty }
  mathml.any |= mathml.coth
  mathml.attlist-coth &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.arcsin = element ns1:arcsin { mathml.attlist-arcsin, empty }
  mathml.any |= mathml.arcsin
  mathml.attlist-arcsin &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.arccos = element ns1:arccos { mathml.attlist-arccos, empty }
  mathml.any |= mathml.arccos
  mathml.attlist-arccos &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.arctan = element ns1:arctan { mathml.attlist-arctan, empty }
  mathml.any |= mathml.arctan
  mathml.attlist-arctan &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.arccosh = element ns1:arccosh { mathml.attlist-arccosh, empty }
  mathml.any |= mathml.arccosh
  mathml.attlist-arccosh &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.arccot = element ns1:arccot { mathml.attlist-arccot, empty }
  mathml.any |= mathml.arccot
  mathml.attlist-arccot &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.arccoth = element ns1:arccoth { mathml.attlist-arccoth, empty }
  mathml.any |= mathml.arccoth
  mathml.attlist-arccoth &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.arccsc = element ns1:arccsc { mathml.attlist-arccsc, empty }
  mathml.any |= mathml.arccsc
  mathml.attlist-arccsc &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.arccsch = element ns1:arccsch { mathml.attlist-arccsch, empty }
  mathml.any |= mathml.arccsch
  mathml.attlist-arccsch &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.arcsec = element ns1:arcsec { mathml.attlist-arcsec, empty }
  mathml.any |= mathml.arcsec
  mathml.attlist-arcsec &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.arcsech = element ns1:arcsech { mathml.attlist-arcsech, empty }
  mathml.any |= mathml.arcsech
  mathml.attlist-arcsech &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.arcsinh = element ns1:arcsinh { mathml.attlist-arcsinh, empty }
  mathml.any |= mathml.arcsinh
  mathml.attlist-arcsinh &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.arctanh = element ns1:arctanh { mathml.attlist-arctanh, empty }
  mathml.any |= mathml.arctanh
  mathml.attlist-arctanh &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.cstatopnary =
    mathml.mean
    | mathml.sdev
    | mathml.variance
    | mathml.median
    | mathml.mode
  mathml.mean = element ns1:mean { mathml.attlist-mean, empty }
  mathml.any |= mathml.mean
  mathml.attlist-mean &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.sdev = element ns1:sdev { mathml.attlist-sdev, empty }
  mathml.any |= mathml.sdev
  mathml.attlist-sdev &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.variance =
    element ns1:variance { mathml.attlist-variance, empty }
  mathml.any |= mathml.variance
  mathml.attlist-variance &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.median = element ns1:median { mathml.attlist-median, empty }
  mathml.any |= mathml.median
  mathml.attlist-median &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.mode = element ns1:mode { mathml.attlist-mode, empty }
  mathml.any |= mathml.mode
  mathml.attlist-mode &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.cstatopmoment = mathml.moment
  mathml.moment = element ns1:moment { mathml.attlist-moment, empty }
  mathml.any |= mathml.moment
  mathml.attlist-moment &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.clalgop1ary = mathml.determinant | mathml.transpose
  mathml.determinant =
    element ns1:determinant { mathml.attlist-determinant, empty }
  mathml.any |= mathml.determinant
  mathml.attlist-determinant &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.transpose =
    element ns1:transpose { mathml.attlist-transpose, empty }
  mathml.any |= mathml.transpose
  mathml.attlist-transpose &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.clalgop2ary =
    mathml.vectorproduct | mathml.scalarproduct | mathml.outerproduct
  mathml.vectorproduct =
    element ns1:vectorproduct { mathml.attlist-vectorproduct, empty }
  mathml.any |= mathml.vectorproduct
  mathml.attlist-vectorproduct &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.scalarproduct =
    element ns1:scalarproduct { mathml.attlist-scalarproduct, empty }
  mathml.any |= mathml.scalarproduct
  mathml.attlist-scalarproduct &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.outerproduct =
    element ns1:outerproduct { mathml.attlist-outerproduct, empty }
  mathml.any |= mathml.outerproduct
  mathml.attlist-outerproduct &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.clalgopnary = mathml.selector
  mathml.selector =
    element ns1:selector { mathml.attlist-selector, empty }
  mathml.any |= mathml.selector
  mathml.attlist-selector &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.cgenrel2ary = mathml.neq | mathml.factorof
  mathml.neq = element ns1:neq { mathml.attlist-neq, empty }
  mathml.any |= mathml.neq
  mathml.attlist-neq &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.factorof =
    element ns1:factorof { mathml.attlist-factorof, empty }
  mathml.any |= mathml.factorof
  mathml.attlist-factorof &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.cgenrelnary =
    mathml.eq
    | mathml.leq
    | mathml.lt
    | mathml.geq
    | mathml.gt
    | mathml.equivalent
    | mathml.approx
  mathml.eq = element ns1:eq { mathml.attlist-eq, empty }
  mathml.any |= mathml.eq
  mathml.attlist-eq &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.equivalent =
    element ns1:equivalent { mathml.attlist-equivalent, empty }
  mathml.any |= mathml.equivalent
  mathml.attlist-equivalent &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.approx = element ns1:approx { mathml.attlist-approx, empty }
  mathml.any |= mathml.approx
  mathml.attlist-approx &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.gt = element ns1:gt { mathml.attlist-gt, empty }
  mathml.any |= mathml.gt
  mathml.attlist-gt &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.lt = element ns1:lt { mathml.attlist-lt, empty }
  mathml.any |= mathml.lt
  mathml.attlist-lt &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.geq = element ns1:geq { mathml.attlist-geq, empty }
  mathml.any |= mathml.geq
  mathml.attlist-geq &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.leq = element ns1:leq { mathml.attlist-leq, empty }
  mathml.any |= mathml.leq
  mathml.attlist-leq &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.csetrel2ary =
    mathml.in | mathml.notin | mathml.notsubset | mathml.notprsubset
  mathml.in = element ns1:in { mathml.attlist-in, empty }
  mathml.any |= mathml.in
  mathml.attlist-in &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.notin = element ns1:notin { mathml.attlist-notin, empty }
  mathml.any |= mathml.notin
  mathml.attlist-notin &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.notsubset =
    element ns1:notsubset { mathml.attlist-notsubset, empty }
  mathml.any |= mathml.notsubset
  mathml.attlist-notsubset &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.notprsubset =
    element ns1:notprsubset { mathml.attlist-notprsubset, empty }
  mathml.any |= mathml.notprsubset
  mathml.attlist-notprsubset &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.csetrelnary = mathml.subset | mathml.prsubset
  mathml.subset = element ns1:subset { mathml.attlist-subset, empty }
  mathml.any |= mathml.subset
  mathml.attlist-subset &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.prsubset =
    element ns1:prsubset { mathml.attlist-prsubset, empty }
  mathml.any |= mathml.prsubset
  mathml.attlist-prsubset &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.cseqrel2ary = mathml.tendsto
  mathml.tendsto = element ns1:tendsto { mathml.attlist-tendsto, empty }
  mathml.any |= mathml.tendsto
  mathml.attlist-tendsto &=
    MATHML.Common.attrib,
    mathml.att-definition,
    mathml.att-encoding,
    mathml.att-type
  mathml.cquantifier =
    mathml.lowlimit
    | mathml.uplimit
    | mathml.bvar
    | mathml.degree
    | mathml.logbase
    | mathml.momentabout
    | mathml.domainofapplication
  mathml.attlist-lowlimit &= MATHML.Common.attrib
  mathml.attlist-uplimit &= MATHML.Common.attrib
  mathml.attlist-bvar &= MATHML.Common.attrib
  mathml.attlist-degree &= MATHML.Common.attrib
  mathml.attlist-logbase &= MATHML.Common.attrib
  mathml.attlist-momentabout &= MATHML.Common.attrib
  mathml.attlist-domainofapplication &= MATHML.Common.attrib
  mathml.cop1ary =
    mathml.cfuncop1ary
    | mathml.carithop1ary
    | mathml.clogicop1ary
    | mathml.ccalcop1ary
    | mathml.ctrigop
    | mathml.clalgop1ary
    | mathml.csetop1ary
  mathml.cop2ary =
    mathml.carithop2ary
    | mathml.clogicop2ary
    | mathml.clalgop2ary
    | mathml.csetop2ary
  mathml.copnary =
    mathml.cfuncopnary
    | mathml.carithopnary
    | mathml.clogicopnary
    | mathml.csetopnary
    | mathml.cstatopnary
    | mathml.clalgopnary
  mathml.copmisc =
    mathml.carithoproot
    | mathml.carithop1or2ary
    | mathml.ccalcop
    | mathml.cseqop
    | mathml.cstatopmoment
    | mathml.clogicopquant
  mathml.crel2ary =
    mathml.cgenrel2ary | mathml.csetrel2ary | mathml.cseqrel2ary
  mathml.crelnary = mathml.cgenrelnary | mathml.csetrelnary
  mathml.Content =
    mathml.ctoken
    | mathml.cspecial
    | mathml.cother
    | mathml.csemantics
    | mathml.c0ary
    | mathml.cconstructor
    | mathml.cquantifier
    | mathml.cop1ary
    | mathml.cop2ary
    | mathml.copnary
    | mathml.copmisc
    | mathml.crel2ary
    | mathml.crelnary
  mathml.ContInPres =
    mathml.ci
    | mathml.csymbol
    | mathml.cn
    | mathml.c0ary
    | mathml.apply
    | mathml.fn
    | mathml.lambda
    | mathml.reln
    | mathml.cconstructor
    | mathml.semantics
    | mathml.declare
  mathml.ContentExpression = (mathml.Content | mathml.PresInCont)*
  mathml.PresExpression = (mathml.Presentation | mathml.ContInPres)*
  mathml.MathExpression = (mathml.PresInCont | mathml.ContInPres)*
  mathml.MathMLCharacters = text | mathml.mglyph
  mathml.ci =
    element ns1:ci {
      mathml.attlist-ci, (mathml.MathMLCharacters | mathml.PresInCont)*
    }
  mathml.any |= mathml.ci
  mathml.csymbol =
    element ns1:csymbol {
      mathml.attlist-csymbol,
      (mathml.MathMLCharacters | mathml.PresInCont)*
    }
  mathml.any |= mathml.csymbol
  mathml.cn =
    element ns1:cn {
      mathml.attlist-cn,
      (mathml.MathMLCharacters | mathml.sep | mathml.PresInCont)*
    }
  mathml.any |= mathml.cn
  mathml.apply =
    element ns1:apply { mathml.attlist-apply, mathml.ContentExpression }
  mathml.any |= mathml.apply
  mathml.reln =
    element ns1:reln { mathml.attlist-reln, mathml.ContentExpression }
  mathml.any |= mathml.reln
  mathml.lambda =
    element ns1:lambda {
      mathml.attlist-lambda, mathml.ContentExpression
    }
  mathml.any |= mathml.lambda
  mathml.condition =
    element ns1:condition {
      mathml.attlist-condition, mathml.ContentExpression
    }
  mathml.any |= mathml.condition
  mathml.declare =
    element ns1:declare {
      mathml.attlist-declare, mathml.ContentExpression
    }
  mathml.any |= mathml.declare
  mathml.semantics =
    element ns1:semantics {
      mathml.attlist-semantics, mathml.ContentExpression
    }
  mathml.any |= mathml.semantics
  mathml.Annotation.content = text
  mathml.annotation =
    element ns1:annotation {
      mathml.attlist-annotation, mathml.Annotation.content
    }
  mathml.any |= mathml.annotation
  mathml.annotation-xml =
    element ns1:annotation-xml {
      mathml.attlist-annotation-xml, mathml.any
    }
  mathml.any |= mathml.annotation-xml
  mathml.interval =
    element ns1:interval {
      mathml.attlist-interval, mathml.ContentExpression
    }
  mathml.any |= mathml.interval
  mathml.set =
    element ns1:set { mathml.attlist-set, mathml.ContentExpression }
  mathml.any |= mathml.set
  mathml.list =
    element ns1:list { mathml.attlist-list, mathml.ContentExpression }
  mathml.any |= mathml.list
  mathml.vector =
    element ns1:vector {
      mathml.attlist-vector, mathml.ContentExpression
    }
  mathml.any |= mathml.vector
  mathml.matrix =
    element ns1:matrix {
      mathml.attlist-matrix, mathml.ContentExpression
    }
  mathml.any |= mathml.matrix
  mathml.matrixrow =
    element ns1:matrixrow {
      mathml.attlist-matrixrow, mathml.ContentExpression
    }
  mathml.any |= mathml.matrixrow
  mathml.piecewise =
    element ns1:piecewise {
      mathml.attlist-piecewise, mathml.piece*, mathml.otherwise?
    }
  mathml.any |= mathml.piecewise
  mathml.piece =
    element ns1:piece { mathml.attlist-piece, mathml.ContentExpression }
  mathml.any |= mathml.piece
  mathml.otherwise =
    element ns1:otherwise {
      mathml.attlist-otherwise, mathml.ContentExpression
    }
  mathml.any |= mathml.otherwise
  mathml.fn =
    element ns1:fn { mathml.attlist-fn, mathml.ContentExpression }
  mathml.any |= mathml.fn
  mathml.lowlimit =
    element ns1:lowlimit {
      mathml.attlist-lowlimit, mathml.ContentExpression
    }
  mathml.any |= mathml.lowlimit
  mathml.uplimit =
    element ns1:uplimit {
      mathml.attlist-uplimit, mathml.ContentExpression
    }
  mathml.any |= mathml.uplimit
  mathml.bvar =
    element ns1:bvar { mathml.attlist-bvar, mathml.ContentExpression }
  mathml.any |= mathml.bvar
  mathml.degree =
    element ns1:degree {
      mathml.attlist-degree, mathml.ContentExpression
    }
  mathml.any |= mathml.degree
  mathml.logbase =
    element ns1:logbase {
      mathml.attlist-logbase, mathml.ContentExpression
    }
  mathml.any |= mathml.logbase
  mathml.momentabout =
    element ns1:momentabout {
      mathml.attlist-momentabout, mathml.ContentExpression
    }
  mathml.any |= mathml.momentabout
  mathml.domainofapplication =
    element ns1:domainofapplication {
      mathml.attlist-domainofapplication, mathml.ContentExpression
    }
  mathml.any |= mathml.domainofapplication
  mathml.mstyle =
    element ns1:mstyle { mathml.attlist-mstyle, mathml.PresExpression }
  mathml.any |= mathml.mstyle
  mathml.merror =
    element ns1:merror { mathml.attlist-merror, mathml.PresExpression }
  mathml.any |= mathml.merror
  mathml.mphantom =
    element ns1:mphantom {
      mathml.attlist-mphantom, mathml.PresExpression
    }
  mathml.any |= mathml.mphantom
  mathml.mrow =
    element ns1:mrow { mathml.attlist-mrow, mathml.PresExpression }
  mathml.any |= mathml.mrow
  mathml.mfrac =
    element ns1:mfrac { mathml.attlist-mfrac, mathml.PresExpression }
  mathml.any |= mathml.mfrac
  mathml.msqrt =
    element ns1:msqrt { mathml.attlist-msqrt, mathml.PresExpression }
  mathml.any |= mathml.msqrt
  mathml.menclose =
    element ns1:menclose {
      mathml.attlist-menclose, mathml.PresExpression
    }
  mathml.any |= mathml.menclose
  mathml.mroot =
    element ns1:mroot { mathml.attlist-mroot, mathml.PresExpression }
  mathml.any |= mathml.mroot
  mathml.msub =
    element ns1:msub { mathml.attlist-msub, mathml.PresExpression }
  mathml.any |= mathml.msub
  mathml.msup =
    element ns1:msup { mathml.attlist-msup, mathml.PresExpression }
  mathml.any |= mathml.msup
  mathml.msubsup =
    element ns1:msubsup {
      mathml.attlist-msubsup, mathml.PresExpression
    }
  mathml.any |= mathml.msubsup
  mathml.mmultiscripts =
    element ns1:mmultiscripts {
      mathml.attlist-mmultiscripts, mathml.PresExpression
    }
  mathml.any |= mathml.mmultiscripts
  mathml.munder =
    element ns1:munder { mathml.attlist-munder, mathml.PresExpression }
  mathml.any |= mathml.munder
  mathml.mover =
    element ns1:mover { mathml.attlist-mover, mathml.PresExpression }
  mathml.any |= mathml.mover
  mathml.munderover =
    element ns1:munderover {
      mathml.attlist-munderover, mathml.PresExpression
    }
  mathml.any |= mathml.munderover
  mathml.mtable =
    element ns1:mtable { mathml.attlist-mtable, mathml.PresExpression }
  mathml.any |= mathml.mtable
  mathml.mtr =
    element ns1:mtr { mathml.attlist-mtr, mathml.PresExpression }
  mathml.any |= mathml.mtr
  mathml.mlabeledtr =
    element ns1:mlabeledtr {
      mathml.attlist-mlabeledtr, mathml.PresExpression
    }
  mathml.any |= mathml.mlabeledtr
  mathml.mtd =
    element ns1:mtd { mathml.attlist-mtd, mathml.PresExpression }
  mathml.any |= mathml.mtd
  mathml.maction =
    element ns1:maction {
      mathml.attlist-maction, mathml.PresExpression
    }
  mathml.any |= mathml.maction
  mathml.mfenced =
    element ns1:mfenced {
      mathml.attlist-mfenced, mathml.PresExpression
    }
  mathml.any |= mathml.mfenced
  mathml.mpadded =
    element ns1:mpadded {
      mathml.attlist-mpadded, mathml.PresExpression
    }
  mathml.any |= mathml.mpadded
  mathml.mi =
    element ns1:mi {
      mathml.attlist-mi, (mathml.MathMLCharacters | mathml.malignmark)*
    }
  mathml.any |= mathml.mi
  mathml.mn =
    element ns1:mn {
      mathml.attlist-mn, (mathml.MathMLCharacters | mathml.malignmark)*
    }
  mathml.any |= mathml.mn
  mathml.mo =
    element ns1:mo {
      mathml.attlist-mo, (mathml.MathMLCharacters | mathml.malignmark)*
    }
  mathml.any |= mathml.mo
  mathml.mtext =
    element ns1:mtext {
      mathml.attlist-mtext,
      (mathml.MathMLCharacters | mathml.malignmark)*
    }
  mathml.any |= mathml.mtext
  mathml.ms =
    element ns1:ms {
      mathml.attlist-ms, (mathml.MathMLCharacters | mathml.malignmark)*
    }
  mathml.any |= mathml.ms
  mathml.att-macros = attribute macros { text }?
  mathml.att-mode = attribute mode { text }?
  mathml.att-display = attribute display { text }?
  mathml.att-topinfo =
    MATHML.Common.attrib,
    mathml.att-macros,
    mathml.att-mode,
    mathml.att-display
  mathml.att-baseline = attribute baseline { text }?
  mathml.att-overflow =
    [ a:defaultValue = "scroll" ]
    attribute overflow { "scroll" | "elide" | "truncate" | "scale" }?
  mathml.att-altimg = attribute altimg { text }?
  mathml.att-alttext = attribute alttext { text }?
  mathml.att-browif =
    mathml.att-type,
    mathml.att-name,
    mathml.att-height,
    mathml.att-width,
    mathml.att-baseline,
    mathml.att-overflow,
    mathml.att-altimg,
    mathml.att-alttext
  mathml.math =
    element ns1:math { mathml.attlist-math, mathml.MathExpression }
  mathml.any |= mathml.math
  mathml.attlist-math &= mathml.att-topinfo, mathml.att-browif
  mathml.any |= text
}
macro.paraContent =
  (text
   | model.gLike
   | model.phrase
   | model.inter
   | model.global
   | mathml.math)*
macro.limitedContent = (text | model.limitedPhrase | model.inter)*
macro.phraseSeq =
  (text | model.gLike | model.phrase | model.global | mathml.math)*
macro.phraseSeq.limited = (text | model.limitedPhrase | model.global)*
macro.specialPara =
  (text
   | model.gLike
   | model.phrase
   | model.inter
   | model.divPart
   | model.global
   | mathml.math)*
macro.xtext = (text | model.gLike)*
macro.anyXML =
  element * - (ns5:* | i:* | ns6:* | ns1:* | ns11:egXML) {
    attribute * { text }*,
    (text | macro.anyXML)*
  }
macro.schemaPattern =
  (text | (pattern | define)+)
  | anySchematron*
anyAlien =
  element ns12:* {
    attribute * { xsd:token }*,
    (text | anyTEI | anyAlien)*
  }
anyTEI =
  param
  | exceptExtrapattern
  | \start
  | define
  | exceptNameClass
  | mathml.mspace
  | mathml.mprescripts
  | mathml.none
  | mathml.malignmark
  | mathml.maligngroup
  | mathml.mglyph
  | mathml.sep
  | mathml.integers
  | mathml.reals
  | mathml.rationals
  | mathml.naturalnumbers
  | mathml.complexes
  | mathml.primes
  | mathml.exponentiale
  | mathml.imaginaryi
  | mathml.notanumber
  | mathml.true
  | mathml.false
  | mathml.emptyset
  | mathml.pi
  | mathml.eulergamma
  | mathml.infinity
  | mathml.inverse
  | mathml.domain
  | mathml.codomain
  | mathml.image
  | mathml.ident
  | mathml.compose
  | mathml.exp
  | mathml.abs
  | mathml.arg
  | mathml.real
  | mathml.imaginary
  | mathml.conjugate
  | mathml.factorial
  | mathml.floor
  | mathml.ceiling
  | mathml.minus
  | mathml.quotient
  | mathml.divide
  | mathml.power
  | mathml.rem
  | mathml.plus
  | mathml.max
  | mathml.min
  | mathml.times
  | mathml.gcd
  | mathml.lcm
  | mathml.root
  | mathml.exists
  | mathml.forall
  | mathml.and
  | mathml.or
  | mathml.xor
  | mathml.not
  | mathml.implies
  | mathml.divergence
  | mathml.grad
  | mathml.curl
  | mathml.laplacian
  | mathml.log
  | mathml.int
  | mathml.diff
  | mathml.partialdiff
  | mathml.ln
  | mathml.card
  | mathml.setdiff
  | mathml.union
  | mathml.intersect
  | mathml.cartesianproduct
  | mathml.sum
  | mathml.product
  | mathml.limit
  | mathml.sin
  | mathml.cos
  | mathml.tan
  | mathml.sec
  | mathml.csc
  | mathml.cot
  | mathml.sinh
  | mathml.cosh
  | mathml.tanh
  | mathml.sech
  | mathml.csch
  | mathml.coth
  | mathml.arcsin
  | mathml.arccos
  | mathml.arctan
  | mathml.arccosh
  | mathml.arccot
  | mathml.arccoth
  | mathml.arccsc
  | mathml.arccsch
  | mathml.arcsec
  | mathml.arcsech
  | mathml.arcsinh
  | mathml.arctanh
  | mathml.mean
  | mathml.sdev
  | mathml.variance
  | mathml.median
  | mathml.mode
  | mathml.moment
  | mathml.determinant
  | mathml.transpose
  | mathml.vectorproduct
  | mathml.scalarproduct
  | mathml.outerproduct
  | mathml.selector
  | mathml.neq
  | mathml.factorof
  | mathml.eq
  | mathml.equivalent
  | mathml.approx
  | mathml.gt
  | mathml.lt
  | mathml.geq
  | mathml.leq
  | mathml.in
  | mathml.notin
  | mathml.notsubset
  | mathml.notprsubset
  | mathml.subset
  | mathml.prsubset
  | mathml.tendsto
  | mathml.ci
  | mathml.csymbol
  | mathml.cn
  | mathml.apply
  | mathml.reln
  | mathml.lambda
  | mathml.condition
  | mathml.declare
  | mathml.semantics
  | mathml.annotation
  | mathml.annotation-xml
  | mathml.interval
  | mathml.set
  | mathml.list
  | mathml.vector
  | mathml.matrix
  | mathml.matrixrow
  | mathml.piecewise
  | mathml.piece
  | mathml.otherwise
  | mathml.fn
  | mathml.lowlimit
  | mathml.uplimit
  | mathml.bvar
  | mathml.degree
  | mathml.logbase
  | mathml.momentabout
  | mathml.domainofapplication
  | mathml.mstyle
  | mathml.merror
  | mathml.mphantom
  | mathml.mrow
  | mathml.mfrac
  | mathml.msqrt
  | mathml.menclose
  | mathml.mroot
  | mathml.msub
  | mathml.msup
  | mathml.msubsup
  | mathml.mmultiscripts
  | mathml.munder
  | mathml.mover
  | mathml.munderover
  | mathml.mtable
  | mathml.mtr
  | mathml.mlabeledtr
  | mathml.mtd
  | mathml.maction
  | mathml.mfenced
  | mathml.mpadded
  | mathml.mi
  | mathml.mn
  | mathml.mo
  | mathml.mtext
  | mathml.ms
  | mathml.math
  | p
  | foreign
  | emph
  | hi
  | quote
  | q
  | cit
  | mentioned
  | desc
  | gloss
  | term
  | add
  | del
  | name
  | address
  | addrLine
  | num
  | date
  | time
  | abbr
  | ptr
  | ref
  | \list
  | item
  | label
  | head
  | note
  | graphic
  | milestone
  | pb
  | lb
  | analytic
  | monogr
  | series
  | author
  | editor
  | respStmt
  | resp
  | title
  | meeting
  | imprint
  | publisher
  | biblScope
  | pubPlace
  | bibl
  | biblStruct
  | listBibl
  | l
  | divGen
  | g
  | teiHeader
  | fileDesc
  | titleStmt
  | sponsor
  | funder
  | principal
  | editionStmt
  | edition
  | extent
  | publicationStmt
  | distributor
  | authority
  | idno
  | availability
  | seriesStmt
  | notesStmt
  | sourceDesc
  | biblFull
  | encodingDesc
  | projectDesc
  | refsDecl
  | classDecl
  | taxonomy
  | category
  | catDesc
  | appInfo
  | application
  | profileDesc
  | creation
  | langUsage
  | language
  | textClass
  | keywords
  | classCode
  | catRef
  | revisionDesc
  | change
  | TEI
  | \text
  | body
  | group
  | \div
  | titlePart
  | front
  | back
  | table
  | row
  | cell
  | formula
  | figure
  | figDesc
  | addSpan
  | delSpan
  | fw
  | orgName
  | persName
  | surname
  | forename
  | listEvent
  | org
  | anchor
  | seg
  | c
  | att
  | code
  | eg
  | egXML
  | gi
  | ident
  | tag
  | val
  | specList
  | specDesc
  | elementRef
  | macroRef
  | moduleRef
  | moduleSpec
  | schemaSpec
  | specGrp
  | specGrpRef
  | stringVal
  | elementSpec
  | classSpec
  | macroSpec
  | remarks
  | listRef
  | exemplum
  | classes
  | memberOf
  | equiv
  | altIdent
  | content
  | constraint
  | constraintSpec
  | attList
  | attDef
  | attRef
  | datatype
  | defaultVal
  | valDesc
  | valItem
  | valList
  | wordObject
  | footer
  | dynamicContent
  | orientation
  | pageNumbering
  | header
  | calstable
  | tgroup
  | colspec
  | calstabletitle
  | thead
  | tbody
  | calsrow
  | entry
  | tbx_admin
  | tbx_descrip
  | tbx_descripGrp
  | tbx_descripNote
  | tbx_hi
  | tbx_langSet
  | tbx_note
  | tbx_ntig
  | tbx_term
  | tbx_ref
  | tbx_termComp
  | tbx_termCompGrp
  | tbx_termCompList
  | tbx_termEntry
  | tbx_termGrp
  | tbx_termNote
anySchematron =
  element s:* {
    (attribute * { text }
     | anySchematron
     | text)*
  }
anyVML =
  element ns8:* {
    attribute * { xsd:token }*,
    (text | anyVML | anyOLE)*
  }
anyOLE =
  element ns4:* {
    attribute * { xsd:token }*,
    (text | anyVML | anyOLE)*
  }
anyOOXML =
  element ns2:* {
    attribute * { xsd:token }*,
    (text | anyOLE | anyVML | anyOOXML)*
  }
anyOOXMLDrawing =
  element ns9:* {
    attribute * { xsd:token }*,
    (text | anyOOXMLDrawingPic | anyOOXMLDrawingMain | anyOOXMLDrawing)*
  }
anyOOXMLDrawingMain =
  element ns10:* {
    attribute * { xsd:token }*,
    (text | anyOOXMLDrawing | anyOOXMLDrawingMain | anyOOXMLDrawingPic)*
  }
anyOOXMLDrawingPic =
  element ns7:* {
    attribute * { xsd:token }*,
    (text | anyOOXMLDrawing | anyOOXMLDrawingMain | anyOOXMLDrawingPic)*
  }
yesorno = "0" | "1"
tbx_entity.noteText =
  (macro.xtext
   | model.segLike
   | model.ptrLike
   | mathml.math
   | tbx_hi
   | hi)*
tbx_entity.auxInfo =
  (tbx_descrip | tbx_descripGrp | tbx_admin | tbx_note | tbx_ref)*
tbx_entity.basicText =
  (macro.xtext
   | model.pPart.transcriptional
   | model.segLike
   | mathml.math
   | hi)*
att.ascribed.attributes = att.ascribed.attribute.who
att.ascribed.attribute.who =
  
  ## indicates the person, or group of people, to whom the element content is ascribed.
  attribute who {
    list { xsd:anyURI, xsd:anyURI* }
  }?
att.canonical.attributes =
  att.canonical.attribute.key, att.canonical.attribute.ref
att.canonical.attribute.key =
  
  ## provides an externally-defined means of identifying the entity (or entities) being
  ##         named, using a coded value of some kind.
  attribute key { xsd:string }?
att.canonical.attribute.ref =
  
  ## (reference) provides an explicit means of locating a full definition for the entity being named by
  ##         means of one or more URIs.
  attribute ref {
    list { xsd:anyURI, xsd:anyURI* }
  }?
att.ranging.attributes =
  att.ranging.attribute.atLeast,
  att.ranging.attribute.atMost,
  att.ranging.attribute.min,
  att.ranging.attribute.max
att.ranging.attribute.atLeast =
  
  ## gives a minimum estimated value for the approximate measurement.
  attribute atLeast {
    xsd:double
    | xsd:token { pattern = "(\-?[\d]+/\-?[\d]+)" }
    | xsd:decimal
  }?
att.ranging.attribute.atMost =
  
  ## gives a maximum estimated value for the approximate measurement.
  attribute atMost {
    xsd:double
    | xsd:token { pattern = "(\-?[\d]+/\-?[\d]+)" }
    | xsd:decimal
  }?
att.ranging.attribute.min =
  
  ## where the measurement summarizes more than one observation
  ##       or a range, supplies the minimum value
  ##         observed.
  attribute min {
    xsd:double
    | xsd:token { pattern = "(\-?[\d]+/\-?[\d]+)" }
    | xsd:decimal
  }?
att.ranging.attribute.max =
  
  ## where the measurement summarizes more than one observation
  ##       or a range, supplies the maximum value
  ##       observed.
  attribute max {
    xsd:double
    | xsd:token { pattern = "(\-?[\d]+/\-?[\d]+)" }
    | xsd:decimal
  }?
att.dimensions.attributes =
  att.ranging.attributes,
  att.dimensions.attribute.unit,
  att.dimensions.attribute.quantity,
  att.dimensions.attribute.extent,
  att.dimensions.attribute.precision,
  att.dimensions.attribute.scope
att.dimensions.attribute.unit =
  
  ## names the unit used for the measurement
  ## Suggested values include: 1] cm(centimetres) ; 2] mm(millimetres) ; 3] in(inches) ; 4] lines; 5] chars(characters) 
  attribute unit {
    
    ## (centimetres) 
    "cm"
    | 
      ## (millimetres) 
      "mm"
    | 
      ## (inches) 
      "in"
    | 
      ## lines of text
      "lines"
    | 
      ## (characters) characters of text
      "chars"
    | xsd:Name
  }?
att.dimensions.attribute.quantity =
  
  ## specifies the length in the units specified
  attribute quantity {
    xsd:double
    | xsd:token { pattern = "(\-?[\d]+/\-?[\d]+)" }
    | xsd:decimal
  }?
att.dimensions.attribute.extent =
  
  ## indicates the size of the object concerned using a project-specific vocabulary combining
  ##         quantity and units in a single string of words. 
  attribute extent {
    list {
      xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" },
      xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" }*
    }
  }?
att.dimensions.attribute.precision =
  
  ## characterizes the precision of the values specified by the other attributes.
  attribute precision { "high" | "medium" | "low" | "unknown" }?
att.dimensions.attribute.scope =
  
  ## where the measurement summarizes more than one observation, specifies the applicability
  ##         of this measurement.
  ## Sample values include: 1] all; 2] most; 3] range
  attribute scope { xsd:Name }?
att.datable.w3c.attributes =
  att.datable.w3c.attribute.period,
  att.datable.w3c.attribute.when,
  att.datable.w3c.attribute.notBefore,
  att.datable.w3c.attribute.notAfter,
  att.datable.w3c.attribute.from,
  att.datable.w3c.attribute.to
att.datable.w3c.attribute.period =
  
  ## supplies a pointer to some location defining a named
  ##       period of time within which the datable item is understood to
  ##       have occurred.
  attribute period { xsd:anyURI }?
att.datable.w3c.attribute.when =
  
  ## supplies the value of the date or time in a standard form,
  ##       e.g. yyyy-mm-dd.
  attribute when {
    xsd:date
    | xsd:gYear
    | xsd:gMonth
    | xsd:gDay
    | xsd:gYearMonth
    | xsd:gMonthDay
    | xsd:time
    | xsd:dateTime
  }?
att.datable.w3c.attribute.notBefore =
  
  ## specifies the earliest possible date for the event in
  ##	  standard form, e.g. yyyy-mm-dd.
  attribute notBefore {
    xsd:date
    | xsd:gYear
    | xsd:gMonth
    | xsd:gDay
    | xsd:gYearMonth
    | xsd:gMonthDay
    | xsd:time
    | xsd:dateTime
  }?
att.datable.w3c.attribute.notAfter =
  
  ## specifies the latest possible date for the event in
  ##	  standard form, e.g. yyyy-mm-dd.
  attribute notAfter {
    xsd:date
    | xsd:gYear
    | xsd:gMonth
    | xsd:gDay
    | xsd:gYearMonth
    | xsd:gMonthDay
    | xsd:time
    | xsd:dateTime
  }?
att.datable.w3c.attribute.from =
  
  ## indicates the starting point of the period in standard form, e.g. yyyy-mm-dd.
  attribute from {
    xsd:date
    | xsd:gYear
    | xsd:gMonth
    | xsd:gDay
    | xsd:gYearMonth
    | xsd:gMonthDay
    | xsd:time
    | xsd:dateTime
  }?
att.datable.w3c.attribute.to =
  
  ## indicates the ending point of the period in standard
  ##	  form, e.g. yyyy-mm-dd.
  attribute to {
    xsd:date
    | xsd:gYear
    | xsd:gMonth
    | xsd:gDay
    | xsd:gYearMonth
    | xsd:gMonthDay
    | xsd:time
    | xsd:dateTime
  }?
att.datable.attributes =
  att.datable.w3c.attributes, att.datable.iso.attributes
att.declarable.attributes = att.declarable.attribute.default
att.declarable.attribute.default =
  
  ## indicates whether or not this element is selected by default when
  ## its parent is selected.
  [ a:defaultValue = "false" ]
  attribute default {
    
    ## This element is selected if its parent is selected
    "true"
    | 
      ## This element can only be selected explicitly, unless it is the
      ## only one of its kind, in which case it is selected if its parent is selected.
      "false"
  }?
att.declaring.attributes = att.declaring.attribute.decls
att.declaring.attribute.decls =
  
  ## identifies one or more declarable elements within the
  ## header, which are understood to apply to the element bearing this
  ## attribute and its content.
  attribute decls {
    list { xsd:anyURI, xsd:anyURI* }
  }?
att.divLike.attributes =
  att.divLike.attribute.org,
  att.divLike.attribute.sample,
  att.divLike.attribute.part
att.divLike.attribute.org =
  
  ## (organization) specifies how the content of the division is organized.
  [ a:defaultValue = "uniform" ]
  attribute org {
    
    ## composite content: i.e. no claim is made about the
    ##		  sequence in which the immediate contents of this division
    ##		  are to be processed, or their inter-relationships.
    "composite"
    | 
      ## uniform content: i.e. the immediate contents of this
      ##		  element are regarded as forming a logical unit, to be
      ##		  processed in sequence.
      "uniform"
  }?
att.divLike.attribute.sample =
  
  ## indicates whether this division is a sample of the
  ##		original source and if so, from which part.
  [ a:defaultValue = "complete" ]
  attribute sample {
    
    ## division lacks material present at end in source.
    "initial"
    | 
      ## division lacks material at start and end.
      "medial"
    | 
      ## division lacks material at start.
      "final"
    | 
      ## position of sampled material within original unknown.
      "unknown"
    | 
      ## division is not a sample.
      "complete"
  }?
att.divLike.attribute.part =
  
  ## specifies whether or not the division is fragmented by
  ##		some other structural element, for example a speech which is
  ##		divided between two or more verse stanzas.
  [ a:defaultValue = "N" ]
  attribute part {
    
    ## (yes) the division is incomplete in some respect
    "Y"
    | 
      ## (no) either the division is complete, or no claim is made as to its completeness.
      "N"
    | 
      ## (initial) the initial part of an incomplete division
      "I"
    | 
      ## (medial) a medial part of an incomplete division
      "M"
    | 
      ## (final) the final part of an incomplete division
      "F"
  }?
att.docStatus.attributes = att.docStatus.attribute.status
att.docStatus.attribute.status =
  
  ## describes the status of a document either currently or, when
  ## associated with a dated element, at the time indicated.
  ## Sample values include: 1] candidate; 2] recommendation; 3] submitted; 4] approved; 5] deprecated; 6] proposed; 7] cleared; 8] embargoed; 9] draft; 10] frozen; 11] expired; 12] unfinished; 13] draft; 14] galley; 15] published; 16] withdrawn; 17] expired 
  [ a:defaultValue = "draft" ] attribute status { xsd:Name }?
att.responsibility.attributes =
  att.responsibility.attribute.cert, att.responsibility.attribute.resp
att.responsibility.attribute.cert =
  
  ## (certainty) signifies the degree of certainty associated with the intervention or interpretation.
  attribute cert { "high" | "medium" | "low" | "unknown" }?
att.responsibility.attribute.resp =
  
  ## (responsible party) indicates the agency responsible for the intervention or interpretation, for example an
  ##         editor or transcriber.
  attribute resp {
    list { xsd:anyURI, xsd:anyURI* }
  }?
att.editLike.attributes =
  att.dimensions.attributes,
  att.responsibility.attributes,
  att.editLike.attribute.evidence,
  att.editLike.attribute.source
att.editLike.attribute.evidence =
  
  ## indicates the nature of the evidence supporting the reliability or accuracy of the
  ##         intervention or interpretation.
  ## Suggested values include: 1] internal; 2] external; 3] conjecture
  attribute evidence {
    
    ## there is internal evidence to support the intervention.
    "internal"
    | 
      ## there is external evidence to support the intervention.
      "external"
    | 
      ## the intervention or interpretation has been made by the editor, cataloguer, or
      ##             scholar on the basis of their expertise.
      "conjecture"
    | xsd:Name
  }?
att.editLike.attribute.source =
  
  ## contains a list of one or more pointers indicating the sources which support the given
  ##         reading.
  attribute source {
    list { xsd:anyURI, xsd:anyURI* }
  }?
att.global.attributes =
  att.global.analytic.attributes,
  att.global.facs.attributes,
  att.global.attribute.style,
  att.global.attribute.meta,
  att.global.attribute.status,
  att.global.attribute.provision,
  att.global.attribute.spaceBefore,
  att.global.attribute.spaceAfter,
  att.global.attribute.align,
  att.global.attribute.replaceable,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.global.attribute.xmlspace
att.global.attribute.style =
  
  ##
  attribute i:style { text }?
att.global.attribute.meta =
  
  ## label a metadata element
  attribute i:meta {
    
    ## Date completed
    "Date completed"
    | 
      ## Dialogue Language
      "Dialogue Language"
    | 
      ## Document number
      "Document number"
    | 
      ## Language
      "Language"
    | 
      ## Solution ID
      "Solution ID"
    | 
      ## Committee
      "committeeReference"
    | 
      ## Complementary Title
      "complementaryTitle"
    | 
      ## Complementary Title in French
      "complementaryTitle_fr"
    | 
      ## Copyright
      "copyright"
    | 
      ## document base name
      "docBaseName"
    | 
      ## Document date
      "docDate"
    | 
      ## Document edition
      "docEdition"
    | 
      ## Document language
      "docLanguage"
    | 
      ## document language
      "docLanguage"
    | 
      ## Document number
      "docNumber"
    | 
      ## Document Part number
      "docPartNumber"
    | 
      ## document reference
      "docReference"
    | 
      ## Document stage
      "docStage"
    | 
      ## Document subtype
      "docSubtype"
    | 
      ## Document Type
      "docType"
    | 
      ## Document Type in full
      "docTypeFull"
    | 
      ## Draft number
      "draftNumber"
    | 
      ## Full title
      "fullTitle"
    | 
      ## Full title in French
      "fullTitle_fr"
    | 
      ## Parts description in Foreword
      "fw_parts"
    | 
      ## Patent description in Foreword
      "fw_patents"
    | 
      ## Revision description in Foreword
      "fw_revision"
    | 
      ## Introductory Title
      "introductoryTitle"
    | 
      ## Introductory Title in French
      "introductoryTitle_fr"
    | 
      ## Main title
      "mainTitle"
    | 
      ## Main title in French
      "mainTitle_fr"
    | 
      ## Organization
      "organization"
    | 
      ## Part Number
      "partNumber"
    | 
      ## Project ID
      "projectId"
    | 
      ## Subcommittee
      "scNumber"
    | 
      ## Secretariat
      "secretariat"
    | 
      ## Serial number
      "serialNumber"
    | 
      ## Producion stage
      "stage"
    | 
      ## Supplementary title
      "supplementTitle"
    | 
      ## Supplementisoary title in French
      "supplementTitle_fr"
    | 
      ## Technical Committee
      "tcNumber"
    | 
      ## Working Group number
      "wgNumber"
    | 
      ##
      "referenceNumber"
  }?
att.global.attribute.status =
  
  ##
  attribute i:status {
    
    ## Normative prose
    "normative"
    | 
      ## Informative or illustrative prose
      "informative"
  }?
att.global.attribute.provision =
  
  ##
  attribute i:provision {
    
    ## Requirement
    "requirement"
    | 
      ## Recommendation
      "recommendation"
    | 
      ## Statement
      "statement"
    | 
      ## Permission
      "permission"
    | 
      ## Capability
      "capability"
    | 
      ## Possibility
      "possibility"
    | 
      ## Possibility
      ##		  and capability
      "possibilityandcapability"
  }?
att.global.attribute.spaceBefore =
  
  ##
  attribute i:spaceBefore { xsd:token }?
att.global.attribute.spaceAfter =
  
  ##
  attribute i:spaceAfter { xsd:token }?
att.global.attribute.align =
  
  ##
  attribute i:align { xsd:token }?
att.global.attribute.replaceable =
  
  ##
  attribute i:replaceable { xsd:token }?
att.global.attribute.xmlid =
  
  ## (identifier) provides a unique identifier for the element bearing the attribute.
  attribute xml:id { xsd:ID }?
att.global.attribute.n =
  
  ## (number) gives a number (or other label) for an element, which is not necessarily unique within
  ##         the document.
  attribute n {
    list {
      xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" },
      xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" }*
    }
  }?
att.global.attribute.xmllang =
  
  ## (language) indicates the language of the element content using a tag generated
  ##         according to BCP 47
  ##                            
  attribute xml:lang { xsd:language }?
att.global.attribute.rend =
  
  ## (rendition) indicates how the element in question was rendered or presented in the source text.
  attribute rend {
    list {
      xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" },
      xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" }*
    }
  }?
att.global.attribute.xmlbase =
  
  ## provides a base URI reference with which applications can resolve relative URI
  ##         references into absolute URI references.
  attribute xml:base { xsd:anyURI }?
att.global.attribute.xmlspace =
  
  ## signals an intention about how white space should be 
  ##       managed by  applications. 
  attribute xml:space {
    
    ## the processor should treat white space according to the
    ##	default XML white space handling rules
    "default"
    | 
      ## the processor should preserve unchanged any and all
      ##	white space in the source
      "preserve"
  }?
att.internetMedia.attributes = att.internetMedia.attribute.mimeType
att.internetMedia.attribute.mimeType =
  
  ## (MIME media type) specifies the applicable multimedia internet mail extension (MIME) media type
  attribute mimeType {
    xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" }
  }?
att.naming.attributes =
  att.canonical.attributes,
  att.naming.attribute.role,
  att.naming.attribute.nymRef
att.naming.attribute.role =
  
  ## may be used to specify further information about the entity referenced by
  ## this name, for example the occupation of a person, or the status of a place. 
  attribute role { xsd:Name }?
att.naming.attribute.nymRef =
  
  ## (reference to the canonical name) provides a means of locating the canonical form
  ##       (nym) of the names associated with the object
  ##        named by
  ##       the element bearing it.
  attribute nymRef {
    list { xsd:anyURI, xsd:anyURI* }
  }?
att.placement.attributes = att.placement.attribute.place
att.placement.attribute.place =
  
  ## 
  ## Suggested values include: 1] below; 2] bottom; 3] margin; 4] top; 5] opposite; 6] overleaf; 7] above; 8] end; 9] inline; 10] inspace
  attribute place {
    list {
      (
       ## below the line
       "below"
       | 
         ## at the foot of the page
         "bottom"
       | 
         ## in the margin (left, right, or both)
         "margin"
       | 
         ## at the top of the page
         "top"
       | 
         ## on the opposite, i.e. facing, page
         "opposite"
       | 
         ## on the other side of the leaf
         "overleaf"
       | 
         ## above the line
         "above"
       | 
         ## at the end of e.g. chapter or volume.
         "end"
       | 
         ## within the body of the text.
         "inline"
       | 
         ##  in a predefined space, for example left by an earlier scribe.
         "inspace"
       | xsd:Name),
      (
       ## below the line
       "below"
       | 
         ## at the foot of the page
         "bottom"
       | 
         ## in the margin (left, right, or both)
         "margin"
       | 
         ## at the top of the page
         "top"
       | 
         ## on the opposite, i.e. facing, page
         "opposite"
       | 
         ## on the other side of the leaf
         "overleaf"
       | 
         ## above the line
         "above"
       | 
         ## at the end of e.g. chapter or volume.
         "end"
       | 
         ## within the body of the text.
         "inline"
       | 
         ##  in a predefined space, for example left by an earlier scribe.
         "inspace"
       | xsd:Name)*
    }
  }?
att.typed.attributes =
  att.typed.attribute.type, att.typed.attribute.subtype
att.typed.attribute.type =
  
  ## characterizes the element in some sense, using any convenient
  ##  classification scheme or typology.
  attribute type { xsd:Name }?
att.typed.attribute.subtype =
  
  ## provides a sub-categorization of the element, if needed
  attribute subtype { xsd:Name }?
att.pointing.attributes = att.pointing.attribute.target
att.pointing.attribute.target =
  
  ## specifies the destination of the reference by supplying one or more URI References
  attribute target {
    list { xsd:anyURI, xsd:anyURI* }
  }?
att.readFrom.attributes = att.readFrom.attribute.source
att.readFrom.attribute.source =
  
  ## specifies the source from which declarations and definitions for
  ## the components of the object being defined may be obtained. 
  attribute source { xsd:anyURI }?
att.segLike.attributes =
  att.segLike.attribute.function, att.segLike.attribute.part
att.segLike.attribute.function =
  
  ## characterizes the function of the segment.
  attribute function { xsd:Name }?
att.segLike.attribute.part =
  
  ## specifies whether or not the segment is fragmented by some other
  ## structural element, for example a clause which is divided between two
  ## or more sentences.
  [ a:defaultValue = "N" ]
  attribute part {
    
    ## (yes) the segment is incomplete in some respect
    "Y"
    | 
      ## (no) either the segment is complete, or no claim is made as to
      ## its completeness
      "N"
    | 
      ## (initial) the initial part of an incomplete segment
      "I"
    | 
      ## (medial) a medial part of an incomplete segment
      "M"
    | 
      ## (final) the final part of an incomplete segment
      "F"
  }?
att.sourced.attributes = att.sourced.attribute.ed
att.sourced.attribute.ed =
  
  ## (edition) supplies an arbitrary identifier for the source edition in which
  ##       the associated feature (for example, a  page, column, or line
  ##       break) occurs at this point in the text.
  attribute ed {
    list { xsd:anyURI, xsd:anyURI* }
  }?
att.spanning.attributes = att.spanning.attribute.spanTo
att.spanning.attribute.spanTo =
  
  ## indicates the end of a span initiated by the element
  ##	bearing this attribute.
  attribute spanTo { xsd:anyURI }?
att.tableDecoration.attributes =
  att.tableDecoration.attribute.role,
  att.tableDecoration.attribute.rows,
  att.tableDecoration.attribute.cols
att.tableDecoration.attribute.role =
  
  ## indicates the kind of information held in this cell or
  ## in each cell of this row.
  ## Suggested values include: 1] label; 2] data
  [ a:defaultValue = "data" ]
  attribute role {
    
    ## labelling or descriptive information only.
    "label"
    | 
      ## data values.
      "data"
    | xsd:Name
  }?
att.tableDecoration.attribute.rows =
  
  ## indicates the number of rows occupied by this cell or row.
  [ a:defaultValue = "1" ] attribute rows { xsd:nonNegativeInteger }?
att.tableDecoration.attribute.cols =
  
  ## (columns) indicates the number of columns occupied by this cell or
  ##	row.
  [ a:defaultValue = "1" ] attribute cols { xsd:nonNegativeInteger }?
att.transcriptional.attributes =
  att.editLike.attributes,
  att.transcriptional.attribute.hand,
  att.transcriptional.attribute.status,
  att.transcriptional.attribute.seq
att.transcriptional.attribute.hand =
  
  ## signifies the hand of the agent which made the intervention.
  attribute hand { xsd:anyURI }?
att.transcriptional.attribute.status =
  
  ## indicates the effect of the intervention, for example in
  ##       the case of a deletion, strikeouts
  ##       which include too much or too little text, or in the case of an
  ##       addition, an insertion which duplicates some of the text
  ##       already present.
  ## Sample values include: 1] duplicate; 2] duplicate-partial; 3] excessStart; 4] excessEnd; 5] shortStart; 6] shortEnd; 7] partial; 8] unremarkable
  [ a:defaultValue = "unremarkable" ] attribute status { xsd:Name }?
att.transcriptional.attribute.seq =
  
  ## (sequence) assigns a sequence number related to the order in which
  ##       the encoded features carrying this attribute are believed to have occurred.
  attribute seq { xsd:nonNegativeInteger }?
att.translatable.attributes = att.translatable.attribute.version
att.translatable.attribute.version =
  
  ## specifies the version name or number of the source from
  ##	which the translated version was derived
  attribute version {
    xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" }
  }?
model.nameLike.agent = name | orgName | persName
model.nameLike.agent_alternation = name | orgName | persName
model.nameLike.agent_sequence = name, orgName, persName
model.nameLike.agent_sequenceOptional = name?, orgName?, persName?
model.nameLike.agent_sequenceOptionalRepeatable =
  name*, orgName*, persName*
model.nameLike.agent_sequenceRepeatable = name+, orgName+, persName+
model.segLike = seg | c
model.segLike_alternation = seg | c
model.segLike_sequence = seg, c
model.segLike_sequenceOptional = seg?, c?
model.segLike_sequenceOptionalRepeatable = seg*, c*
model.segLike_sequenceRepeatable = seg+, c+
model.hiLike = hi
model.hiLike_alternation = hi
model.hiLike_sequence = hi
model.hiLike_sequenceOptional = hi?
model.hiLike_sequenceOptionalRepeatable = hi*
model.hiLike_sequenceRepeatable = hi+
model.emphLike =
  foreign | emph | mentioned | gloss | term | title | code | ident
model.emphLike_alternation =
  foreign | emph | mentioned | gloss | term | title | code | ident
model.emphLike_sequence =
  foreign, emph, mentioned, gloss, term, title, code, ident
model.emphLike_sequenceOptional =
  foreign?, emph?, mentioned?, gloss?, term?, title?, code?, ident?
model.emphLike_sequenceOptionalRepeatable =
  foreign*, emph*, mentioned*, gloss*, term*, title*, code*, ident*
model.emphLike_sequenceRepeatable =
  foreign+, emph+, mentioned+, gloss+, term+, title+, code+, ident+
model.highlighted = model.hiLike | model.emphLike
model.highlighted_alternation =
  model.hiLike_alternation | model.emphLike_alternation
model.highlighted_sequence =
  model.hiLike_sequence, model.emphLike_sequence
model.highlighted_sequenceOptional =
  model.hiLike_sequenceOptional?, model.emphLike_sequenceOptional?
model.highlighted_sequenceOptionalRepeatable =
  model.hiLike_sequenceOptionalRepeatable*,
  model.emphLike_sequenceOptionalRepeatable*
model.highlighted_sequenceRepeatable =
  model.hiLike_sequenceRepeatable+, model.emphLike_sequenceRepeatable+
model.dateLike = date | time
model.dateLike_alternation = date | time
model.dateLike_sequence = date, time
model.dateLike_sequenceOptional = date?, time?
model.dateLike_sequenceOptionalRepeatable = date*, time*
model.dateLike_sequenceRepeatable = date+, time+
model.measureLike = num
model.measureLike_alternation = num
model.measureLike_sequence = num
model.measureLike_sequenceOptional = num?
model.measureLike_sequenceOptionalRepeatable = num*
model.measureLike_sequenceRepeatable = num+
model.egLike = eg | egXML
model.egLike_alternation = eg | egXML
model.egLike_sequence = eg, egXML
model.egLike_sequenceOptional = eg?, egXML?
model.egLike_sequenceOptionalRepeatable = eg*, egXML*
model.egLike_sequenceRepeatable = eg+, egXML+
model.graphicLike = graphic | formula
model.graphicLike_alternation = graphic | formula
model.graphicLike_sequence = graphic, formula
model.graphicLike_sequenceOptional = graphic?, formula?
model.graphicLike_sequenceOptionalRepeatable = graphic*, formula*
model.graphicLike_sequenceRepeatable = graphic+, formula+
model.pPart.editorial = abbr
model.pPart.editorial_alternation = abbr
model.pPart.editorial_sequence = abbr
model.pPart.editorial_sequenceOptional = abbr?
model.pPart.editorial_sequenceOptionalRepeatable = abbr*
model.pPart.editorial_sequenceRepeatable = abbr+
model.pPart.transcriptional = add | del
model.pPart.transcriptional_alternation = add | del
model.pPart.transcriptional_sequence = add, del
model.pPart.transcriptional_sequenceOptional = add?, del?
model.pPart.transcriptional_sequenceOptionalRepeatable = add*, del*
model.pPart.transcriptional_sequenceRepeatable = add+, del+
model.pPart.edit = model.pPart.editorial | model.pPart.transcriptional
model.pPart.edit_alternation =
  model.pPart.editorial_alternation
  | model.pPart.transcriptional_alternation
model.pPart.edit_sequence =
  model.pPart.editorial_sequence, model.pPart.transcriptional_sequence
model.pPart.edit_sequenceOptional =
  model.pPart.editorial_sequenceOptional?,
  model.pPart.transcriptional_sequenceOptional?
model.pPart.edit_sequenceOptionalRepeatable =
  model.pPart.editorial_sequenceOptionalRepeatable*,
  model.pPart.transcriptional_sequenceOptionalRepeatable*
model.pPart.edit_sequenceRepeatable =
  model.pPart.editorial_sequenceRepeatable+,
  model.pPart.transcriptional_sequenceRepeatable+
model.ptrLike = ptr | ref
model.ptrLike_alternation = ptr | ref
model.ptrLike_sequence = ptr, ref
model.ptrLike_sequenceOptional = ptr?, ref?
model.ptrLike_sequenceOptionalRepeatable = ptr*, ref*
model.ptrLike_sequenceRepeatable = ptr+, ref+
model.milestoneLike = milestone | pb | lb | fw | anchor | wordObject
model.milestoneLike_alternation =
  milestone | pb | lb | fw | anchor | wordObject
model.milestoneLike_sequence = milestone, pb, lb, fw, anchor, wordObject
model.milestoneLike_sequenceOptional =
  milestone?, pb?, lb?, fw?, anchor?, wordObject?
model.milestoneLike_sequenceOptionalRepeatable =
  milestone*, pb*, lb*, fw*, anchor*, wordObject*
model.milestoneLike_sequenceRepeatable =
  milestone+, pb+, lb+, fw+, anchor+, wordObject+
model.gLike = g
model.oddDecl =
  moduleSpec | specGrp | elementSpec | classSpec | macroSpec | listRef
model.oddDecl_alternation =
  moduleSpec | specGrp | elementSpec | classSpec | macroSpec | listRef
model.oddDecl_sequence =
  moduleSpec, specGrp, elementSpec, classSpec, macroSpec, listRef
model.oddDecl_sequenceOptional =
  moduleSpec?, specGrp?, elementSpec?, classSpec?, macroSpec?, listRef?
model.oddDecl_sequenceOptionalRepeatable =
  moduleSpec*, specGrp*, elementSpec*, classSpec*, macroSpec*, listRef*
model.oddDecl_sequenceRepeatable =
  moduleSpec+, specGrp+, elementSpec+, classSpec+, macroSpec+, listRef+
model.oddRef = elementRef | macroRef | moduleRef | specGrpRef
model.oddRef_alternation =
  elementRef | macroRef | moduleRef | specGrpRef
model.oddRef_sequence = elementRef, macroRef, moduleRef, specGrpRef
model.oddRef_sequenceOptional =
  elementRef?, macroRef?, moduleRef?, specGrpRef?
model.oddRef_sequenceOptionalRepeatable =
  elementRef*, macroRef*, moduleRef*, specGrpRef*
model.oddRef_sequenceRepeatable =
  elementRef+, macroRef+, moduleRef+, specGrpRef+
model.phrase.xml = att | gi | tag | val
model.phrase.xml_alternation = att | gi | tag | val
model.phrase.xml_sequence = att, gi, tag, val
model.phrase.xml_sequenceOptional = att?, gi?, tag?, val?
model.phrase.xml_sequenceOptionalRepeatable = att*, gi*, tag*, val*
model.phrase.xml_sequenceRepeatable = att+, gi+, tag+, val+
model.specDescLike = specList | specDesc
model.specDescLike_alternation = specList | specDesc
model.specDescLike_sequence = specList, specDesc
model.specDescLike_sequenceOptional = specList?, specDesc?
model.specDescLike_sequenceOptionalRepeatable = specList*, specDesc*
model.specDescLike_sequenceRepeatable = specList+, specDesc+
model.biblLike = bibl | biblStruct | biblFull
model.biblLike_alternation = bibl | biblStruct | biblFull
model.biblLike_sequence = bibl, biblStruct, biblFull
model.biblLike_sequenceOptional = bibl?, biblStruct?, biblFull?
model.biblLike_sequenceOptionalRepeatable =
  bibl*, biblStruct*, biblFull*
model.biblLike_sequenceRepeatable = bibl+, biblStruct+, biblFull+
model.headLike = head
model.headLike_alternation = head
model.headLike_sequence = head
model.headLike_sequenceOptional = head?
model.headLike_sequenceOptionalRepeatable = head*
model.headLike_sequenceRepeatable = head+
model.labelLike = desc | label
model.labelLike_alternation = desc | label
model.labelLike_sequence = desc, label
model.labelLike_sequenceOptional = desc?, label?
model.labelLike_sequenceOptionalRepeatable = desc*, label*
model.labelLike_sequenceRepeatable = desc+, label+
model.listLike = \list | listBibl | listEvent
model.listLike_alternation = \list | listBibl | listEvent
model.listLike_sequence = \list, listBibl, listEvent
model.listLike_sequenceOptional = \list?, listBibl?, listEvent?
model.listLike_sequenceOptionalRepeatable =
  \list*, listBibl*, listEvent*
model.listLike_sequenceRepeatable = \list+, listBibl+, listEvent+
model.noteLike = note
model.noteLike_alternation = note
model.noteLike_sequence = note
model.noteLike_sequenceOptional = note?
model.noteLike_sequenceOptionalRepeatable = note*
model.noteLike_sequenceRepeatable = note+
model.lLike = l
model.lLike_alternation = l
model.lLike_sequence = l
model.lLike_sequenceOptional = l?
model.lLike_sequenceOptionalRepeatable = l*
model.lLike_sequenceRepeatable = l+
model.pLike = p
model.pLike_alternation = p
model.pLike_sequence = p
model.pLike_sequenceOptional = p?
model.pLike_sequenceOptionalRepeatable = p*
model.pLike_sequenceRepeatable = p+
model.entryPart = notAllowed
model.global.edit = addSpan | delSpan
model.global.edit_alternation = addSpan | delSpan
model.global.edit_sequence = addSpan, delSpan
model.global.edit_sequenceOptional = addSpan?, delSpan?
model.global.edit_sequenceOptionalRepeatable = addSpan*, delSpan*
model.global.edit_sequenceRepeatable = addSpan+, delSpan+
model.divPart = model.lLike | model.pLike | schemaSpec
model.divPart_alternation =
  model.lLike_alternation | model.pLike_alternation | schemaSpec
model.divPart_sequence =
  model.lLike_sequence, model.pLike_sequence, schemaSpec
model.divPart_sequenceOptional =
  model.lLike_sequenceOptional?,
  model.pLike_sequenceOptional?,
  schemaSpec?
model.divPart_sequenceOptionalRepeatable =
  model.lLike_sequenceOptionalRepeatable*,
  model.pLike_sequenceOptionalRepeatable*,
  schemaSpec*
model.divPart_sequenceRepeatable =
  model.lLike_sequenceRepeatable+,
  model.pLike_sequenceRepeatable+,
  schemaSpec+
model.persStateLike = persName
model.persStateLike_alternation = persName
model.persStateLike_sequence = persName
model.persStateLike_sequenceOptional = persName?
model.persStateLike_sequenceOptionalRepeatable = persName*
model.persStateLike_sequenceRepeatable = persName+
model.personLike = org
model.publicationStmtPart =
  address
  | date
  | publisher
  | pubPlace
  | distributor
  | authority
  | idno
  | availability
model.glossLike = desc | gloss | equiv | altIdent
model.quoteLike = quote | cit
model.quoteLike_alternation = quote | cit
model.quoteLike_sequence = quote, cit
model.quoteLike_sequenceOptional = quote?, cit?
model.quoteLike_sequenceOptionalRepeatable = quote*, cit*
model.quoteLike_sequenceRepeatable = quote+, cit+
model.qLike = model.quoteLike | q
model.qLike_alternation = model.quoteLike_alternation | q
model.qLike_sequence = model.quoteLike_sequence, q
model.qLike_sequenceOptional = model.quoteLike_sequenceOptional?, q?
model.qLike_sequenceOptionalRepeatable =
  model.quoteLike_sequenceOptionalRepeatable*, q*
model.qLike_sequenceRepeatable = model.quoteLike_sequenceRepeatable+, q+
model.respLike =
  author | editor | respStmt | meeting | sponsor | funder | principal
model.respLike_alternation =
  author | editor | respStmt | meeting | sponsor | funder | principal
model.respLike_sequence =
  author, editor, respStmt, meeting, sponsor, funder, principal
model.respLike_sequenceOptional =
  author?, editor?, respStmt?, meeting?, sponsor?, funder?, principal?
model.respLike_sequenceOptionalRepeatable =
  author*, editor*, respStmt*, meeting*, sponsor*, funder*, principal*
model.respLike_sequenceRepeatable =
  author+, editor+, respStmt+, meeting+, sponsor+, funder+, principal+
model.divWrapper = meeting
model.divWrapper_alternation = meeting
model.divWrapper_sequence = meeting
model.divWrapper_sequenceOptional = meeting?
model.divWrapper_sequenceOptionalRepeatable = meeting*
model.divWrapper_sequenceRepeatable = meeting+
model.divTopPart = model.headLike
model.divTopPart_alternation = model.headLike_alternation
model.divTopPart_sequence = model.headLike_sequence
model.divTopPart_sequenceOptional = model.headLike_sequenceOptional?
model.divTopPart_sequenceOptionalRepeatable =
  model.headLike_sequenceOptionalRepeatable*
model.divTopPart_sequenceRepeatable = model.headLike_sequenceRepeatable+
model.divTop = model.divWrapper | model.divTopPart
model.pLike.front = head | titlePart
model.divBottomPart = notAllowed
model.divBottomPart_alternation = notAllowed
model.divBottomPart_sequence = empty
model.divBottomPart_sequenceOptional = empty
model.divBottomPart_sequenceOptionalRepeatable = empty
model.divBottomPart_sequenceRepeatable = notAllowed
model.divBottom = model.divWrapper | model.divBottomPart
model.msQuoteLike = title
model.msQuoteLike_alternation = title
model.msQuoteLike_sequence = title
model.msQuoteLike_sequenceOptional = title?
model.msQuoteLike_sequenceOptionalRepeatable = title*
model.msQuoteLike_sequenceRepeatable = title+
model.imprintPart = publisher | biblScope | pubPlace | distributor
model.imprintPart_alternation =
  publisher | biblScope | pubPlace | distributor
model.imprintPart_sequence = publisher, biblScope, pubPlace, distributor
model.imprintPart_sequenceOptional =
  publisher?, biblScope?, pubPlace?, distributor?
model.imprintPart_sequenceOptionalRepeatable =
  publisher*, biblScope*, pubPlace*, distributor*
model.imprintPart_sequenceRepeatable =
  publisher+, biblScope+, pubPlace+, distributor+
model.catDescPart = notAllowed
model.addressLike = address
model.addressLike_alternation = address
model.addressLike_sequence = address
model.addressLike_sequenceOptional = address?
model.addressLike_sequenceOptionalRepeatable = address*
model.addressLike_sequenceRepeatable = address+
model.nameLike = model.nameLike.agent | idno | model.persNamePart
model.nameLike_alternation =
  model.nameLike.agent_alternation
  | idno
  | model.persNamePart_alternation
model.nameLike_sequence =
  model.nameLike.agent_sequence, idno, model.persNamePart_sequence
model.nameLike_sequenceOptional =
  model.nameLike.agent_sequenceOptional?,
  idno?,
  model.persNamePart_sequenceOptional?
model.nameLike_sequenceOptionalRepeatable =
  model.nameLike.agent_sequenceOptionalRepeatable*,
  idno*,
  model.persNamePart_sequenceOptionalRepeatable*
model.nameLike_sequenceRepeatable =
  model.nameLike.agent_sequenceRepeatable+,
  idno+,
  model.persNamePart_sequenceRepeatable+
model.global =
  model.milestoneLike | model.noteLike | model.global.edit | figure
model.biblPart =
  model.respLike | model.imprintPart | series | edition | extent
model.frontPart = divGen
model.addrPart = model.nameLike | addrLine
model.pPart.data =
  model.dateLike
  | model.measureLike
  | model.addressLike
  | model.nameLike
model.pPart.data_alternation =
  model.dateLike_alternation
  | model.measureLike_alternation
  | model.addressLike_alternation
  | model.nameLike_alternation
model.pPart.data_sequence =
  model.dateLike_sequence,
  model.measureLike_sequence,
  model.addressLike_sequence,
  model.nameLike_sequence
model.pPart.data_sequenceOptional =
  model.dateLike_sequenceOptional?,
  model.measureLike_sequenceOptional?,
  model.addressLike_sequenceOptional?,
  model.nameLike_sequenceOptional?
model.pPart.data_sequenceOptionalRepeatable =
  model.dateLike_sequenceOptionalRepeatable*,
  model.measureLike_sequenceOptionalRepeatable*,
  model.addressLike_sequenceOptionalRepeatable*,
  model.nameLike_sequenceOptionalRepeatable*
model.pPart.data_sequenceRepeatable =
  model.dateLike_sequenceRepeatable+,
  model.measureLike_sequenceRepeatable+,
  model.addressLike_sequenceRepeatable+,
  model.nameLike_sequenceRepeatable+
model.inter =
  model.egLike
  | model.oddDecl
  | model.oddRef
  | model.biblLike
  | model.labelLike
  | model.listLike
  | model.qLike
  | table
  | calstable
  | tbx_termEntry
model.inter_alternation =
  model.egLike_alternation
  | model.oddDecl_alternation
  | model.oddRef_alternation
  | model.biblLike_alternation
  | model.labelLike_alternation
  | model.listLike_alternation
  | model.qLike_alternation
  | table
  | calstable
  | tbx_termEntry
model.inter_sequence =
  model.egLike_sequence,
  model.oddDecl_sequence,
  model.oddRef_sequence,
  model.biblLike_sequence,
  model.labelLike_sequence,
  model.listLike_sequence,
  model.qLike_sequence,
  table,
  calstable,
  tbx_termEntry
model.inter_sequenceOptional =
  model.egLike_sequenceOptional?,
  model.oddDecl_sequenceOptional?,
  model.oddRef_sequenceOptional?,
  model.biblLike_sequenceOptional?,
  model.labelLike_sequenceOptional?,
  model.listLike_sequenceOptional?,
  model.qLike_sequenceOptional?,
  table?,
  calstable?,
  tbx_termEntry?
model.inter_sequenceOptionalRepeatable =
  model.egLike_sequenceOptionalRepeatable*,
  model.oddDecl_sequenceOptionalRepeatable*,
  model.oddRef_sequenceOptionalRepeatable*,
  model.biblLike_sequenceOptionalRepeatable*,
  model.labelLike_sequenceOptionalRepeatable*,
  model.listLike_sequenceOptionalRepeatable*,
  model.qLike_sequenceOptionalRepeatable*,
  table*,
  calstable*,
  tbx_termEntry*
model.inter_sequenceRepeatable =
  model.egLike_sequenceRepeatable+,
  model.oddDecl_sequenceRepeatable+,
  model.oddRef_sequenceRepeatable+,
  model.biblLike_sequenceRepeatable+,
  model.labelLike_sequenceRepeatable+,
  model.listLike_sequenceRepeatable+,
  model.qLike_sequenceRepeatable+,
  table+,
  calstable+,
  tbx_termEntry+
model.common = model.divPart | model.inter
model.phrase =
  model.segLike
  | model.highlighted
  | model.graphicLike
  | model.pPart.edit
  | model.ptrLike
  | model.phrase.xml
  | model.specDescLike
  | model.pPart.data
  | dynamicContent
model.limitedPhrase =
  model.emphLike
  | model.pPart.editorial
  | model.ptrLike
  | model.phrase.xml
  | model.pPart.data
model.divLike = \div
model.divGenLike = divGen
model.div1Like = notAllowed
model.resourceLike = notAllowed
att.personal.attributes =
  att.naming.attributes,
  att.personal.attribute.full,
  att.personal.attribute.sort
att.personal.attribute.full =
  
  ## indicates whether the name component is given in full, as an
  ## abbreviation or simply as an initial.
  [ a:defaultValue = "yes" ]
  attribute full {
    
    ## the name component is spelled out in full.
    "yes"
    | 
      ## (abbreviated) the name component is given in an abbreviated form.
      "abb"
    | 
      ## (initial letter) the name component is indicated only by
      ## one initial.
      "init"
  }?
att.personal.attribute.sort =
  
  ## specifies the sort order of the name component in relation
  ## to others within the personal name.
  attribute sort { xsd:nonNegativeInteger }?
model.placeLike = notAllowed
p =
  
  ## (paragraph) marks paragraphs in prose.
  element ns6:p {
    macro.paraContent,
    att.global.attributes,
    att.declaring.attributes,
    empty
  }
foreign =
  
  ## (foreign) identifies a word or phrase as belonging to some language other than that of the
  ##                 surrounding text. 
  element ns6:foreign { macro.phraseSeq, att.global.attributes, empty }
emph =
  
  ## (emphasized) marks words or phrases which are stressed or emphasized for
  ##         linguistic or rhetorical effect.
  element ns6:emph { macro.paraContent, att.global.attributes, empty }
hi =
  
  ## (highlighted) marks a word or phrase as graphically distinct from the
  ##         surrounding text, for reasons concerning which no claim is
  ##         made. 
  element ns6:hi {
    macro.paraContent,
    
    ## 
    ## Suggested values include: 1] bold; 2] smallcaps; 3] capsall; 4] underline; 5] underdoubleline; 6] strikethrough; 7] strikedoublethrough; 8] italic; 9] superscript; 10] subscript; 11] code; 12] domain; 13] gender; 14] geographicalUse; 15] language; 16] pronunciation; 17] partOfSpeech; 18] source; 19] tab; 20] termRef
    attribute rend {
      list {
        (
         ## Bold
         "bold"
         | 
           ## Smallcaps
           "smallcaps"
         | 
           ## All caps
           "capsall"
         | 
           ## Underline
           "underline"
         | 
           ## Double underline
           "underdoubleline"
         | 
           ## Strikethrough
           "strikethrough"
         | 
           ## Double strikethrough
           "strikedoublethrough"
         | 
           ## Italic
           "italic"
         | 
           ## Superscript
           "superscript"
         | 
           ## Subscript
           "subscript"
         | 
           ## Monospaced font
           "code"
         | 
           ## Terminological  domain
           "domain"
         | 
           ## Terminological gender
           "gender"
         | 
           ## Terminological geographical use
           "geographicalUse"
         | 
           ## Terminological language
           "language"
         | 
           ## Pronunciation
           "pronunciation"
         | 
           ## Part Of Speech
           "partOfSpeech"
         | 
           ## Terminology source
           "source"
         | 
           ## tab
           "tab"
         | 
           ## Terminology Reference
           "termRef"
         | xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" }),
        (
         ## Bold
         "bold"
         | 
           ## Smallcaps
           "smallcaps"
         | 
           ## All caps
           "capsall"
         | 
           ## Underline
           "underline"
         | 
           ## Double underline
           "underdoubleline"
         | 
           ## Strikethrough
           "strikethrough"
         | 
           ## Double strikethrough
           "strikedoublethrough"
         | 
           ## Italic
           "italic"
         | 
           ## Superscript
           "superscript"
         | 
           ## Subscript
           "subscript"
         | 
           ## Monospaced font
           "code"
         | 
           ## Terminological  domain
           "domain"
         | 
           ## Terminological gender
           "gender"
         | 
           ## Terminological geographical use
           "geographicalUse"
         | 
           ## Terminological language
           "language"
         | 
           ## Pronunciation
           "pronunciation"
         | 
           ## Part Of Speech
           "partOfSpeech"
         | 
           ## Terminology source
           "source"
         | 
           ## tab
           "tab"
         | 
           ## Terminology Reference
           "termRef"
         | xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" })?,
        (
         ## Bold
         "bold"
         | 
           ## Smallcaps
           "smallcaps"
         | 
           ## All caps
           "capsall"
         | 
           ## Underline
           "underline"
         | 
           ## Double underline
           "underdoubleline"
         | 
           ## Strikethrough
           "strikethrough"
         | 
           ## Double strikethrough
           "strikedoublethrough"
         | 
           ## Italic
           "italic"
         | 
           ## Superscript
           "superscript"
         | 
           ## Subscript
           "subscript"
         | 
           ## Monospaced font
           "code"
         | 
           ## Terminological  domain
           "domain"
         | 
           ## Terminological gender
           "gender"
         | 
           ## Terminological geographical use
           "geographicalUse"
         | 
           ## Terminological language
           "language"
         | 
           ## Pronunciation
           "pronunciation"
         | 
           ## Part Of Speech
           "partOfSpeech"
         | 
           ## Terminology source
           "source"
         | 
           ## tab
           "tab"
         | 
           ## Terminology Reference
           "termRef"
         | xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" })?,
        (
         ## Bold
         "bold"
         | 
           ## Smallcaps
           "smallcaps"
         | 
           ## All caps
           "capsall"
         | 
           ## Underline
           "underline"
         | 
           ## Double underline
           "underdoubleline"
         | 
           ## Strikethrough
           "strikethrough"
         | 
           ## Double strikethrough
           "strikedoublethrough"
         | 
           ## Italic
           "italic"
         | 
           ## Superscript
           "superscript"
         | 
           ## Subscript
           "subscript"
         | 
           ## Monospaced font
           "code"
         | 
           ## Terminological  domain
           "domain"
         | 
           ## Terminological gender
           "gender"
         | 
           ## Terminological geographical use
           "geographicalUse"
         | 
           ## Terminological language
           "language"
         | 
           ## Pronunciation
           "pronunciation"
         | 
           ## Part Of Speech
           "partOfSpeech"
         | 
           ## Terminology source
           "source"
         | 
           ## tab
           "tab"
         | 
           ## Terminology Reference
           "termRef"
         | xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" })?,
        (
         ## Bold
         "bold"
         | 
           ## Smallcaps
           "smallcaps"
         | 
           ## All caps
           "capsall"
         | 
           ## Underline
           "underline"
         | 
           ## Double underline
           "underdoubleline"
         | 
           ## Strikethrough
           "strikethrough"
         | 
           ## Double strikethrough
           "strikedoublethrough"
         | 
           ## Italic
           "italic"
         | 
           ## Superscript
           "superscript"
         | 
           ## Subscript
           "subscript"
         | 
           ## Monospaced font
           "code"
         | 
           ## Terminological  domain
           "domain"
         | 
           ## Terminological gender
           "gender"
         | 
           ## Terminological geographical use
           "geographicalUse"
         | 
           ## Terminological language
           "language"
         | 
           ## Pronunciation
           "pronunciation"
         | 
           ## Part Of Speech
           "partOfSpeech"
         | 
           ## Terminology source
           "source"
         | 
           ## tab
           "tab"
         | 
           ## Terminology Reference
           "termRef"
         | xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" })?,
        (
         ## Bold
         "bold"
         | 
           ## Smallcaps
           "smallcaps"
         | 
           ## All caps
           "capsall"
         | 
           ## Underline
           "underline"
         | 
           ## Double underline
           "underdoubleline"
         | 
           ## Strikethrough
           "strikethrough"
         | 
           ## Double strikethrough
           "strikedoublethrough"
         | 
           ## Italic
           "italic"
         | 
           ## Superscript
           "superscript"
         | 
           ## Subscript
           "subscript"
         | 
           ## Monospaced font
           "code"
         | 
           ## Terminological  domain
           "domain"
         | 
           ## Terminological gender
           "gender"
         | 
           ## Terminological geographical use
           "geographicalUse"
         | 
           ## Terminological language
           "language"
         | 
           ## Pronunciation
           "pronunciation"
         | 
           ## Part Of Speech
           "partOfSpeech"
         | 
           ## Terminology source
           "source"
         | 
           ## tab
           "tab"
         | 
           ## Terminology Reference
           "termRef"
         | xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" })?,
        (
         ## Bold
         "bold"
         | 
           ## Smallcaps
           "smallcaps"
         | 
           ## All caps
           "capsall"
         | 
           ## Underline
           "underline"
         | 
           ## Double underline
           "underdoubleline"
         | 
           ## Strikethrough
           "strikethrough"
         | 
           ## Double strikethrough
           "strikedoublethrough"
         | 
           ## Italic
           "italic"
         | 
           ## Superscript
           "superscript"
         | 
           ## Subscript
           "subscript"
         | 
           ## Monospaced font
           "code"
         | 
           ## Terminological  domain
           "domain"
         | 
           ## Terminological gender
           "gender"
         | 
           ## Terminological geographical use
           "geographicalUse"
         | 
           ## Terminological language
           "language"
         | 
           ## Pronunciation
           "pronunciation"
         | 
           ## Part Of Speech
           "partOfSpeech"
         | 
           ## Terminology source
           "source"
         | 
           ## tab
           "tab"
         | 
           ## Terminology Reference
           "termRef"
         | xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" })?,
        (
         ## Bold
         "bold"
         | 
           ## Smallcaps
           "smallcaps"
         | 
           ## All caps
           "capsall"
         | 
           ## Underline
           "underline"
         | 
           ## Double underline
           "underdoubleline"
         | 
           ## Strikethrough
           "strikethrough"
         | 
           ## Double strikethrough
           "strikedoublethrough"
         | 
           ## Italic
           "italic"
         | 
           ## Superscript
           "superscript"
         | 
           ## Subscript
           "subscript"
         | 
           ## Monospaced font
           "code"
         | 
           ## Terminological  domain
           "domain"
         | 
           ## Terminological gender
           "gender"
         | 
           ## Terminological geographical use
           "geographicalUse"
         | 
           ## Terminological language
           "language"
         | 
           ## Pronunciation
           "pronunciation"
         | 
           ## Part Of Speech
           "partOfSpeech"
         | 
           ## Terminology source
           "source"
         | 
           ## tab
           "tab"
         | 
           ## Terminology Reference
           "termRef"
         | xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" })?,
        (
         ## Bold
         "bold"
         | 
           ## Smallcaps
           "smallcaps"
         | 
           ## All caps
           "capsall"
         | 
           ## Underline
           "underline"
         | 
           ## Double underline
           "underdoubleline"
         | 
           ## Strikethrough
           "strikethrough"
         | 
           ## Double strikethrough
           "strikedoublethrough"
         | 
           ## Italic
           "italic"
         | 
           ## Superscript
           "superscript"
         | 
           ## Subscript
           "subscript"
         | 
           ## Monospaced font
           "code"
         | 
           ## Terminological  domain
           "domain"
         | 
           ## Terminological gender
           "gender"
         | 
           ## Terminological geographical use
           "geographicalUse"
         | 
           ## Terminological language
           "language"
         | 
           ## Pronunciation
           "pronunciation"
         | 
           ## Part Of Speech
           "partOfSpeech"
         | 
           ## Terminology source
           "source"
         | 
           ## tab
           "tab"
         | 
           ## Terminology Reference
           "termRef"
         | xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" })?,
        (
         ## Bold
         "bold"
         | 
           ## Smallcaps
           "smallcaps"
         | 
           ## All caps
           "capsall"
         | 
           ## Underline
           "underline"
         | 
           ## Double underline
           "underdoubleline"
         | 
           ## Strikethrough
           "strikethrough"
         | 
           ## Double strikethrough
           "strikedoublethrough"
         | 
           ## Italic
           "italic"
         | 
           ## Superscript
           "superscript"
         | 
           ## Subscript
           "subscript"
         | 
           ## Monospaced font
           "code"
         | 
           ## Terminological  domain
           "domain"
         | 
           ## Terminological gender
           "gender"
         | 
           ## Terminological geographical use
           "geographicalUse"
         | 
           ## Terminological language
           "language"
         | 
           ## Pronunciation
           "pronunciation"
         | 
           ## Part Of Speech
           "partOfSpeech"
         | 
           ## Terminology source
           "source"
         | 
           ## tab
           "tab"
         | 
           ## Terminology Reference
           "termRef"
         | xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" })?,
        (
         ## Bold
         "bold"
         | 
           ## Smallcaps
           "smallcaps"
         | 
           ## All caps
           "capsall"
         | 
           ## Underline
           "underline"
         | 
           ## Double underline
           "underdoubleline"
         | 
           ## Strikethrough
           "strikethrough"
         | 
           ## Double strikethrough
           "strikedoublethrough"
         | 
           ## Italic
           "italic"
         | 
           ## Superscript
           "superscript"
         | 
           ## Subscript
           "subscript"
         | 
           ## Monospaced font
           "code"
         | 
           ## Terminological  domain
           "domain"
         | 
           ## Terminological gender
           "gender"
         | 
           ## Terminological geographical use
           "geographicalUse"
         | 
           ## Terminological language
           "language"
         | 
           ## Pronunciation
           "pronunciation"
         | 
           ## Part Of Speech
           "partOfSpeech"
         | 
           ## Terminology source
           "source"
         | 
           ## tab
           "tab"
         | 
           ## Terminology Reference
           "termRef"
         | xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" })?,
        (
         ## Bold
         "bold"
         | 
           ## Smallcaps
           "smallcaps"
         | 
           ## All caps
           "capsall"
         | 
           ## Underline
           "underline"
         | 
           ## Double underline
           "underdoubleline"
         | 
           ## Strikethrough
           "strikethrough"
         | 
           ## Double strikethrough
           "strikedoublethrough"
         | 
           ## Italic
           "italic"
         | 
           ## Superscript
           "superscript"
         | 
           ## Subscript
           "subscript"
         | 
           ## Monospaced font
           "code"
         | 
           ## Terminological  domain
           "domain"
         | 
           ## Terminological gender
           "gender"
         | 
           ## Terminological geographical use
           "geographicalUse"
         | 
           ## Terminological language
           "language"
         | 
           ## Pronunciation
           "pronunciation"
         | 
           ## Part Of Speech
           "partOfSpeech"
         | 
           ## Terminology source
           "source"
         | 
           ## tab
           "tab"
         | 
           ## Terminology Reference
           "termRef"
         | xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" })?
      }
    },
    att.global.attribute.style,
    att.global.attribute.meta,
    att.global.attribute.status,
    att.global.attribute.provision,
    att.global.attribute.spaceBefore,
    att.global.attribute.spaceAfter,
    att.global.attribute.align,
    att.global.attribute.replaceable,
    att.global.attribute.xmlid,
    att.global.attribute.n,
    att.global.attribute.xmllang,
    att.global.attribute.xmlbase,
    att.global.attribute.xmlspace,
    att.global.analytic.attributes,
    att.global.facs.attributes,
    empty
  }
quote =
  
  ## (quotation) contains a phrase or passage attributed by the narrator or author to some agency external
  ##         to the text.
  element ns6:quote {
    macro.specialPara,
    att.global.attributes,
    att.typed.attributes,
    empty
  }
q =
  
  ## (separated from the surrounding text with quotation marks) contains material which is marked as (ostensibly) being somehow different than the
  ##     surrounding text, for any one of a variety of reasons including, but not limited to: direct
  ##     speech or thought, technical terms or jargon, authorial distance, quotations from elsewhere, and
  ##     passages that are mentioned but not used.
  element ns6:q {
    macro.specialPara,
    att.global.attributes,
    att.ascribed.attributes,
    
    ## may be used to indicate whether the offset passage is spoken or thought, or to
    ##         characterize it more finely.
    ## Suggested values include: 1] spoken; 2] thought; 3] written; 4] soCalled; 5] foreign(foreign words) ; 6] distinct(linguistically distinct) ; 7] term(technical term) ; 8] emph(rhetorically emphasized) ; 9] mentioned
    attribute type {
      
      ## representation of speech
      "spoken"
      | 
        ## representation of thought, e.g. internal monologue
        "thought"
      | 
        ## quotation from a written source
        "written"
      | 
        ## authorial distance
        "soCalled"
      | 
        ## (foreign words) 
        "foreign"
      | 
        ## (linguistically distinct) 
        "distinct"
      | 
        ## (technical term) 
        "term"
      | 
        ## (rhetorically emphasized) 
        "emph"
      | 
        ## refering to itself, not its normal referant
        "mentioned"
      | xsd:Name
    }?,
    empty
  }
cit =
  
  ## (cited quotation) contains a quotation from some other document, together with a bibliographic reference to
  ##     its source. In a dictionary it may contain an example text with at least one occurrence of the
  ##     word form, used in the sense being described, or a translation of the headword, or an example. 
  element ns6:cit {
    (model.qLike
     | model.biblLike
     | model.ptrLike
     | model.global
     | model.entryPart)+,
    att.global.attributes,
    att.typed.attributes,
    empty
  }
mentioned =
  
  ## marks words or phrases mentioned, not used.
  element ns6:mentioned {
    macro.phraseSeq, att.global.attributes, empty
  }
desc =
  
  ## (description) contains a brief description of the object documented by its parent element, including its
  ##     intended usage, purpose, or application where this is appropriate.
  element ns6:desc {
    macro.limitedContent,
    att.global.attributes,
    att.translatable.attributes,
    empty
  }
gloss =
  
  ## identifies a phrase or word used to provide a gloss or definition for some other word or
  ##     phrase.
  element ns6:gloss {
    macro.phraseSeq,
    att.global.attributes,
    att.declaring.attributes,
    att.translatable.attributes,
    att.typed.attributes,
    att.pointing.attributes,
    
    ## (canonical reference) identifies the associated term element using a canonical reference from a
    ##         scheme defined in a refsDecl element in the TEI header
    attribute cRef { xsd:anyURI }?,
    empty
  }
term =
  
  ## contains a single-word, multi-word, or symbolic designation which is regarded as a technical
  ##     term.
  element ns6:term {
    macro.phraseSeq,
    att.global.attributes,
    att.declaring.attributes,
    att.pointing.attributes,
    att.typed.attributes,
    att.canonical.attributes,
    
    ## identifies the associated gloss element using a canonical reference from a
    ##           scheme defined in a refsDecl element in the TEI header
    attribute cRef { xsd:anyURI }?,
    
    ## supplies the sort key for this term in an index.
    attribute sortKey {
      xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" }
    }?,
    empty
  }
add =
  
  ## (addition) contains letters, words, or phrases inserted in the text by an
  ##         author, scribe, annotator, or corrector.
  element ns6:add {
    macro.paraContent,
    att.global.attributes,
    att.datable.attributes,
    att.transcriptional.attributes,
    att.placement.attributes,
    att.typed.attributes,
    empty
  }
del =
  
  ## (deletion) contains a letter, word, or passage deleted, marked as deleted, or otherwise indicated as
  ##     superfluous or spurious in the copy text by an author, scribe, annotator, or corrector.
  element ns6:del {
    macro.paraContent,
    att.global.attributes,
    att.datable.attributes,
    att.transcriptional.attributes,
    att.typed.attributes,
    empty
  }
name =
  
  ## (name, proper noun) contains a proper noun or noun phrase.
  element ns6:name {
    macro.phraseSeq,
    att.global.attributes,
    att.naming.attributes,
    att.typed.attributes,
    empty
  }
address =
  
  ## contains a postal  address, for example of a
  ##         publisher, an organization, or an individual.
  element ns6:address {
    (model.global*, (model.addrPart, model.global*)+),
    att.global.attributes,
    empty
  }
addrLine =
  
  ## (address line) contains one line of a postal address.
  element ns6:addrLine { macro.phraseSeq, att.global.attributes, empty }
num =
  
  ## (number) contains a number, written in any form.
  element ns6:num {
    macro.phraseSeq,
    att.global.attributes,
    att.ranging.attributes,
    
    ## indicates the type of numeric value.
    ## Suggested values include: 1] cardinal; 2] ordinal; 3] fraction; 4] percentage
    attribute type {
      
      ## absolute number, e.g. 21, 21.5
      "cardinal"
      | 
        ## ordinal number, e.g. 21st
        "ordinal"
      | 
        ## fraction, e.g. one half or three-quarters
        "fraction"
      | 
        ## a percentage
        "percentage"
      | xsd:Name
    }?,
    
    ## supplies the value of the number in standard form.
    attribute value {
      xsd:double
      | xsd:token { pattern = "(\-?[\d]+/\-?[\d]+)" }
      | xsd:decimal
    }?,
    empty
  }
date =
  
  ## contains a date in any format.
  element ns6:date {
    (text | model.gLike | model.phrase | model.global)*,
    att.global.attributes,
    att.datable.attributes,
    att.editLike.attributes,
    att.typed.attributes,
    
    ## indicates the system or calendar to which the date represented by the content of this
    ##         element belongs.
    ## Suggested values include: 1] Gregorian; 2] Julian; 3] Islamic; 4] Hebrew; 5] Revolutionary; 6] Iranian; 7] Coptic; 8] Chinese
    attribute calendar {
      
      ## Gregorian calendar
      "Gregorian"
      | 
        ## Julian calendar
        "Julian"
      | 
        ## Islamic or Muslim (hijri) lunar calendar
        "Islamic"
      | 
        ## Hebrew or Jewish lunisolar calendar
        "Hebrew"
      | 
        ## French Revolutionary calendar
        "Revolutionary"
      | 
        ## Iranian or Persian (Jalaali) solar calendar
        "Iranian"
      | 
        ## Coptic or Alexandrian calendar
        "Coptic"
      | 
        ## Chinese lunisolar calendar
        "Chinese"
      | xsd:Name
    }?,
    empty
  }
time =
  
  ## contains a phrase defining a time of day in any format.
  element ns6:time {
    (text | model.gLike | model.phrase | model.global)*,
    att.global.attributes,
    att.datable.attributes,
    att.editLike.attributes,
    att.typed.attributes,
    empty
  }
abbr =
  
  ## (abbreviation) contains an abbreviation of any sort.
  element ns6:abbr {
    macro.phraseSeq,
    att.global.attributes,
    att.responsibility.attributes,
    
    ## allows the encoder to classify the abbreviation according to some convenient
    ##                 typology.
    ## Sample values include: 1] suspension; 2] contraction; 3] brevigraph; 4] superscription; 5] acronym; 6] title; 7] organization; 8] geographic
    attribute type { xsd:Name }?,
    empty
  }
ptr =
  
  ## (pointer) defines a pointer to another location.
  element ns6:ptr {
    empty
    >> sch:pattern [
         id = "ptr-constraint-ptrAtts"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "tei:ptr"
           "\x{a}" ~
           "               "
           sch:report [
             test = "@target and @cRef"
             "Only one of the\x{a}" ~
             "	attributes 'target' and 'cRef' may be supplied."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    att.global.attributes,
    att.pointing.attributes,
    att.typed.attributes,
    att.declaring.attributes,
    empty
  }
ref =
  
  ## (reference) defines a reference to another location, possibly modified by additional text or comment.
  element ns6:ref {
    macro.paraContent
    >> sch:pattern [
         id = "ref-constraint-refAtts"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "tei:ref"
           "\x{a}" ~
           "               "
           sch:report [
             test = "@target and @cRef"
             "Only one of the\x{a}" ~
             "	attributes 'target' and 'cRef' may be supplied."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    att.global.attributes,
    att.pointing.attributes,
    att.typed.attributes,
    att.declaring.attributes,
    empty
  }
\list =
  
  ## (list) contains any sequence of items organized as a list.
  element ns6:list {
    ((model.divTop | model.global)*,
     ((item, model.global*)+
      | (label, model.global*, item, model.global*)+),
     (model.divBottom, model.global*)*)
    >> s:pattern [
         name = "isoList"
         "\x{a}" ~
         "		                            "
         s:rule [
           context = "tei:list[@type='termlist']/tei:item"
           "\x{a}" ~
           "		                               "
           s:assert [
             test = "@n"
             "Each item in a termlist must have a @n attribute"
           ]
           "\x{a}" ~
           "		                            "
         ]
         "\x{a}" ~
         "		                         "
       ],
    
    ##
    attribute type {
      
      ## Numbered list
      "ordered"
      | 
        ## Bulletted list
        "unordered"
      | 
        ## Definition list
        "gloss"
    },
    att.global.attributes,
    empty
  }
item =
  
  ## contains one component of a list.
  element ns6:item { macro.specialPara, att.global.attributes, empty }
label =
  
  ## contains the label associated with an item in a list; in glossaries, marks the term being
  ##     defined.
  element ns6:label { macro.phraseSeq, att.global.attributes, empty }
head =
  
  ## (heading) contains any type of heading, for example the title of a section, or the heading of a list,
  ##     glossary, manuscript description, etc.
  element ns6:head {
    macro.paraContent,
    att.global.attributes,
    att.typed.attributes,
    empty
  }
note =
  
  ## contains a note or annotation.
  element ns6:note {
    macro.specialPara,
    
    ##
    attribute place {
      
      ##
      "inline"
      | 
        ##
        "foot"
      | 
        ##
        "bottom"
      | 
        ##
        "end"
      | 
        ##
        "comment"
    }?,
    
    ## indicates whether the copy text shows the exact place of reference for the note.
    [ a:defaultValue = "true" ] attribute anchored { xsd:boolean }?,
    
    ## points to the end of the span to which the note is attached, if the note is not embedded
    ##         in the text at that point.
    attribute targetEnd {
      list { xsd:anyURI, xsd:anyURI* }
    }?,
    att.global.attributes,
    att.pointing.attributes,
    att.responsibility.attributes,
    att.typed.attributes,
    empty
  }
graphic =
  
  ## indicates the location of an inline graphic, illustration, or figure.
  element ns6:graphic {
    model.glossLike*,
    att.global.attributes,
    att.internetMedia.attributes,
    att.declaring.attributes,
    
    ## The display width of the image
    attribute width {
      xsd:token {
        pattern =
          "[\-+]?\d+(\.\d+)?(%|cm|mm|in|pt|pc|px|em|ex|gd|rem|vw|vh|vm)"
      }
    }?,
    
    ## The display height of the image
    attribute height {
      xsd:token {
        pattern =
          "[\-+]?\d+(\.\d+)?(%|cm|mm|in|pt|pc|px|em|ex|gd|rem|vw|vh|vm)"
      }
    }?,
    
    ## A scale factor to be applied to the image to make it the desired display size
    attribute scale {
      xsd:double
      | xsd:token { pattern = "(\-?[\d]+/\-?[\d]+)" }
      | xsd:decimal
    }?,
    
    ## (uniform resource locator) A URL which refers to the image itself.
    attribute url { xsd:anyURI },
    empty
  }
milestone =
  
  ## marks a boundary point separating any kind of section of a text, typically but not
  ##     necessarily indicating a point at which some part of a standard reference system changes, where
  ##     the change is not represented by a structural element.
  element ns6:milestone {
    (orientation | footer | header | pageNumbering)*,
    
    ## provides a conventional name for the kind of section changing at this milestone.
    ## Suggested values include: 1] page; 2] column; 3] line; 4] book; 5] poem; 6] canto; 7] speaker; 8] stanza; 9] act; 10] scene; 11] section; 12] absent; 13] unnumbered
    attribute unit {
      
      ## physical page breaks (synonymous with the pb element).
      "page"
      | 
        ## column breaks.
        "column"
      | 
        ## line breaks (synonymous with the lb element).
        "line"
      | 
        ## any units termed book, liber, etc.
        "book"
      | 
        ## individual poems in a collection.
        "poem"
      | 
        ## cantos or other major sections of a poem.
        "canto"
      | 
        ## changes of speaker or narrator.
        "speaker"
      | 
        ## stanzas within a poem, book, or canto.
        "stanza"
      | 
        ## acts within a play.
        "act"
      | 
        ## scenes within a play or act.
        "scene"
      | 
        ## sections of any kind.
        "section"
      | 
        ## passages not present in the reference edition.
        "absent"
      | 
        ## passages present in the text, but not to be included as part of the reference.
        "unnumbered"
      | xsd:Name
    },
    att.global.attributes,
    att.typed.attributes,
    att.sourced.attributes,
    empty
  }
pb =
  
  ## (page break) marks the boundary between one page of a text and the next in a standard reference system.
  element ns6:pb {
    empty,
    att.global.attributes,
    att.typed.attributes,
    att.sourced.attributes,
    empty
  }
lb =
  
  ## (line break) marks the start of a new (typographic) line in some edition or version of a text.
  element ns6:lb {
    empty,
    att.global.attributes,
    att.typed.attributes,
    att.sourced.attributes,
    empty
  }
analytic =
  
  ## (analytic level) contains bibliographic elements describing an item (e.g. an article or poem) published
  ##     within a monograph or journal and not as an independent publication.
  element ns6:analytic {
    (author | editor | respStmt | title | ref)*,
    att.global.attributes,
    empty
  }
monogr =
  
  ## (monographic level) contains bibliographic elements describing an item (e.g. a book or journal) published as an
  ##     independent item (i.e. as a separate physical object).
  element ns6:monogr {
    ((((author | editor | respStmt),
       (author | editor | respStmt)*,
       title+,
       (idno | editor | respStmt)*)
      | ((title | ref)+, (idno | author | editor | respStmt)*))?,
     (model.noteLike | meeting)*,
     (edition, (idno | editor | respStmt)*)*,
     imprint,
     (imprint | extent | biblScope)*),
    att.global.attributes,
    empty
  }
series =
  
  ## (series information) contains information about the series in which a book or other bibliographic item has
  ##     appeared.
  element ns6:series {
    (text
     | model.gLike
     | title
     | ref
     | editor
     | respStmt
     | biblScope
     | model.global)*,
    att.global.attributes,
    empty
  }
author =
  
  ## in a bibliographic reference, contains the name(s) of the
  ##   author(s), personal or corporate, of a work; for example in the same
  ##   form as that provided by a recognized bibliographic name authority. 
  element ns6:author {
    macro.phraseSeq, att.global.attributes, att.naming.attributes, empty
  }
editor =
  
  ## secondary statement of responsibility for a bibliographic item, for example the name of an
  ##     individual, institution or organization, (or of several such) acting as editor, compiler,
  ##     translator, etc. 
  element ns6:editor {
    macro.phraseSeq, att.global.attributes, att.naming.attributes, empty
  }
respStmt =
  
  ## (statement of responsibility) supplies a statement of responsibility for the intellectual content of a text, edition,
  ##     recording, or series, where the specialized elements for authors, editors, etc. do not suffice
  ##     or do not apply.
  element ns6:respStmt {
    ((resp+, model.nameLike.agent+) | (model.nameLike.agent+, resp+)),
    att.global.attributes,
    empty
  }
resp =
  
  ## (responsibility) contains a phrase describing the nature of a person's intellectual responsibility.
  element ns6:resp {
    macro.phraseSeq.limited,
    att.global.attributes,
    att.canonical.attributes,
    empty
  }
title =
  
  ## contains a title for any kind of work.
  element ns6:title {
    macro.paraContent,
    att.global.attributes,
    att.canonical.attributes,
    
    ## indicates the bibliographic level for a title, that is, whether
    ##                                         it identifies an article, book, journal, series, or
    ##                                         unpublished material.
    attribute level {
      
      ## (analytic) analytic title (article, poem, or other item
      ##                                                   published as part of a larger item) 
      "a"
      | 
        ## (monographic) monographic title (book, collection, or
        ##                                                   other item published as a distinct item,
        ##                                                   including single volumes of multi-volume
        ##                                                   works) 
        "m"
      | 
        ## (journal) journal title 
        "j"
      | 
        ## (series) series title 
        "s"
      | 
        ## (unpublished) title of unpublished material (including
        ##                                                   theses and dissertations unless
        ##                                                   published by a commercial press)
        "u"
    }?,
    
    ## classifies the title according to some convenient typology.
    ## Sample values include: 1] main; 2] sub(subordinate) ; 3] alt(alternate) ; 4] short; 5] desc(descriptive) 
    attribute type { xsd:Name }?,
    empty
  }
meeting =
  
  ## contains the formalized descriptive title for a meeting or conference, for use in a
  ##     bibliographic description for an item derived from such a meeting, or as a heading or preamble
  ##     to publications emanating from it.
  element ns6:meeting {
    macro.limitedContent, att.global.attributes, empty
  }
imprint =
  
  ## groups information relating to the publication or distribution
  ##         of a bibliographic item.
  element ns6:imprint {
    ((model.imprintPart | model.dateLike), model.global*)+,
    att.global.attributes,
    empty
  }
publisher =
  
  ## provides the name of the organization responsible for the publication or distribution of a
  ##         bibliographic item.
  element ns6:publisher {
    macro.phraseSeq, att.global.attributes, empty
  }
biblScope =
  
  ## (scope of citation) defines the scope of a bibliographic reference, for example as a
  ##         list of page numbers, or a named subdivision of a larger work.
  element ns6:biblScope {
    macro.phraseSeq,
    att.global.attributes,
    
    ## identifies the type of information conveyed by the element, e.g.
    ##                 columns, pages, volume.
    ## Suggested values include: 1] vol(volume) ; 2] issue; 3] pp(pages) ; 4] ll (lines) ; 5] chap(chapter) ; 6] part
    attribute type {
      
      ## (volume) the element contains a volume number.
      "vol"
      | 
        ## the element contains an issue number, or volume and
        ##                         issue numbers.
        "issue"
      | 
        ## (pages) the element contains a page number or page range.
        "pp"
      | 
        ##  (lines) the element contains a line number or line range.
        "ll"
      | 
        ## (chapter) the element contains a chapter indication (number
        ##                         and/or title)
        "chap"
      | 
        ## the element identifies a part of a book or collection.
        "part"
      | xsd:Name
    }?,
    
    ## specifies the starting point of the range of units indicated by the type attribute.
    attribute from {
      xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" }
    }?,
    
    ## specifies the end-point of the range of units indicated by the type attribute.
    attribute to {
      xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" }
    }?,
    empty
  }
pubPlace =
  
  ## (publication place) contains the name of the place where a bibliographic item was published.
  element ns6:pubPlace {
    macro.phraseSeq, att.global.attributes, att.naming.attributes, empty
  }
bibl =
  
  ## (bibliographic citation) contains a loosely-structured bibliographic citation of which the sub-components may or may
  ##     not be explicitly tagged. 
  element ns6:bibl {
    (text
     | model.gLike
     | model.highlighted
     | model.pPart.data
     | model.pPart.edit
     | model.segLike
     | model.ptrLike
     | model.biblPart
     | model.global)*,
    att.global.attributes,
    att.declarable.attributes,
    att.typed.attributes,
    empty
  }
biblStruct =
  
  ## (structured bibliographic citation) contains a structured bibliographic citation, in which only bibliographic sub-elements
  ##     appear and in a specified order. 
  element ns6:biblStruct {
    (analytic*, (monogr, series*)+, (model.noteLike | idno)*),
    att.global.attributes,
    att.declarable.attributes,
    att.typed.attributes,
    empty
  }
listBibl =
  
  ## (citation list) contains a list of bibliographic citations of any kind. 
  element ns6:listBibl {
    (model.headLike*,
     (model.biblLike | model.milestoneLike | listBibl)+),
    att.global.attributes,
    att.declarable.attributes,
    att.typed.attributes,
    empty
  }
l =
  
  ## (verse line) contains a single, possibly incomplete, line of verse.
  element ns6:l {
    macro.paraContent,
    att.global.attributes,
    
    ## specifies whether or not the line is metrically complete. 
    [ a:defaultValue = "N" ]
    attribute part {
      
      ## (yes) the line is metrically incomplete
      "Y"
      | 
        ## (no) either the line is complete, or no claim is made as to its completeness
        "N"
      | 
        ## (initial) the initial part of an incomplete line
        "I"
      | 
        ## (medial) a medial part of an incomplete line
        "M"
      | 
        ## (final) the final part of an incomplete line
        "F"
    }?,
    empty
  }
divGen =
  
  ## (automatically generated text division) indicates the location at which a textual division generated
  ##         automatically by a text-processing application is to appear.
  element ns6:divGen {
    model.headLike*,
    att.global.attributes,
    
    ## specifies what type of generated text division (e.g. index,
    ##                 table of contents, etc.) is to appear.
    ## Sample values include: 1] index; 2] toc; 3] figlist; 4] tablist
    attribute type { xsd:Name }?,
    empty
  }
g =
  
  ## (character or glyph) represents a non-standard character or glyph.
  element ns6:g {
    text,
    att.global.attributes,
    att.typed.attributes,
    
    ## points to a description of the character or glyph intended.
    attribute ref { xsd:anyURI }?,
    empty
  }
model.teiHeaderPart = encodingDesc | profileDesc
teiHeader =
  
  ## (TEI Header) supplies the descriptive and declarative information making up an electronic title page
  ##     prefixed to every TEI-conformant text.
  element ns6:teiHeader {
    (fileDesc, model.teiHeaderPart*, revisionDesc?)
    >> s:pattern [
         name = "isoHeader-title"
         "\x{a}" ~
         "		                            "
         s:rule [
           context = "tei:teiHeader"
           "\x{a}" ~
           "		                               "
           s:assert [
             test =
               "tei:fileDesc/tei:titleStmt/tei:title[@i:meta='introductoryTitle']"
             "\x{a}" ~
             "		      An introductory component of the title is expected\x{a}" ~
             "		    "
           ]
           "\x{a}" ~
           "		                               "
           s:assert [
             test =
               "tei:fileDesc/tei:titleStmt/tei:title[@i:meta='mainTitle']"
             "\x{a}" ~
             "		      A main component of the title is expected\x{a}" ~
             "		    "
           ]
           "\x{a}" ~
           "		                               "
           s:assert [
             test = "tei:fileDesc/tei:titleStmt/tei:respStmt/tei:name"
             "\x{a}" ~
             "		      No respStmt has been provided, giving SC/TC committee numbers\x{a}" ~
             "		  "
           ]
           "\x{a}" ~
           "		                               "
           s:assert [
             test =
               "tei:fileDesc/tei:publicationStmt/tei:idno[@i:meta='serialNumber']"
             "\x{a}" ~
             "		  an idno of type serialNumber is expected"
           ]
           "\x{a}" ~
           "		                               "
           s:assert [
             test =
               "tei:fileDesc/tei:publicationStmt/tei:idno[@i:meta='stage']"
             "\x{a}" ~
             "		  an idno of type stage is expected"
           ]
           "\x{a}" ~
           "		                            "
         ]
         "\x{a}" ~
         "		                         "
       ],
    
    ## specifies the kind of document to which the header is attached, for example whether it
    ##         is a corpus or individual text.
    ## Sample values include: 1] text; 2] corpus
    [ a:defaultValue = "text" ] attribute type { xsd:Name }?,
    att.global.attributes,
    empty
  }
fileDesc =
  
  ## (file description) contains a full bibliographic description of an electronic file.
  element ns6:fileDesc {
    ((titleStmt,
      editionStmt?,
      extent?,
      publicationStmt,
      seriesStmt?,
      notesStmt?),
     sourceDesc+),
    att.global.attributes,
    empty
  }
titleStmt =
  
  ## (title statement) groups information about the title of a work and those responsible for its intellectual
  ##     content.
  element ns6:titleStmt {
    (title+, model.respLike*), att.global.attributes, empty
  }
sponsor =
  
  ## specifies the name of a sponsoring organization or institution.
  element ns6:sponsor {
    macro.phraseSeq.limited, att.global.attributes, empty
  }
funder =
  
  ## (funding body) specifies the name of an individual, institution, or organization responsible for the
  ##     funding of a project or text.
  element ns6:funder {
    macro.phraseSeq.limited, att.global.attributes, empty
  }
principal =
  
  ## (principal researcher) supplies the name of the principal researcher responsible for the
  ## creation of an electronic text.
  element ns6:principal {
    macro.phraseSeq.limited, att.global.attributes, empty
  }
editionStmt =
  
  ## (edition statement) groups information relating to one edition of a text.
  element ns6:editionStmt {
    (model.pLike+ | (edition, respStmt*)),
    att.global.attributes,
    empty
  }
edition =
  
  ## (edition) describes the particularities of one edition of a text.
  element ns6:edition { macro.phraseSeq, att.global.attributes, empty }
extent =
  
  ## describes the approximate size of a text as stored on some carrier medium, whether digital
  ##     or non-digital, specified in any convenient units.
  element ns6:extent { macro.phraseSeq, att.global.attributes, empty }
publicationStmt =
  
  ## (publication statement) groups information concerning the publication or distribution of an electronic or other
  ##     text. 
  element ns6:publicationStmt {
    (model.pLike+ | model.publicationStmtPart+),
    att.global.attributes,
    empty
  }
distributor =
  
  ## supplies the name of a person or other agency responsible for the
  ## distribution of a text.
  element ns6:distributor {
    macro.phraseSeq, att.global.attributes, empty
  }
authority =
  
  ## (release authority) supplies the name of a person or other agency responsible for
  ##   making an electronic file available, other than a publisher or
  ##   distributor.
  element ns6:authority {
    (
     ##
     "ABNT"
     | 
       ##
       "AENOR"
     | 
       ##
       "AFNOR"
     | 
       ##
       "ANSI"
     | 
       ##
       "ASRO"
     | 
       ##
       "AZSTAND"
     | 
       ##
       "BDS"
     | 
       ##
       "BELST"
     | 
       ##
       "BIS"
     | 
       ##
       "BPS"
     | 
       ##
       "BSI"
     | 
       ##
       "BSJ"
     | 
       ##
       "BSN"
     | 
       ##
       "CNI"
     | 
       ##
       "CODINORM"
     | 
       ##
       "CSK"
     | 
       ##
       "CYS"
     | 
       ##
       "DGN"
     | 
       ##
       "DIGENOR"
     | 
       ##
       "DIN"
     | 
       ##
       "DS"
     | 
       ##
       "DSM"
     | 
       ##
       "DSSU"
     | 
       ##
       "ELOT"
     | 
       ##
       "EOS"
     | 
       ##
       "EVS"
     | 
       ##
       "FONDONORMA"
     | 
       ##
       "GOST-R"
     | 
       ##
       "HZN"
     | 
       ##
       "IANOR"
     | 
       ##
       "ICONTEC"
     | 
       ##
       "INDECOPI"
     | 
       ##
       "INEN"
     | 
       ##
       "INN"
     | 
       ##
       "INNORPI"
     | 
       ##
       "INTECO"
     | 
       ##
       "IPQ"
     | 
       ##
       "IRAM"
     | 
       ##
       "ISIRI"
     | 
       ##
       "ISS"
     | 
       ##
       "IST"
     | 
       ##
       "ITCHKSAR"
     | 
       ##
       "JISC"
     | 
       ##
       "KATS"
     | 
       ##
       "KAZMEMST"
     | 
       ##
       "KEBS"
     | 
       ##
       "LIBNOR"
     | 
       ##
       "LST"
     | 
       ##
       "MASM"
     | 
       ##
       "MSA"
     | 
       ##
       "MSZT"
     | 
       ##
       "NBN"
     | 
       ##
       "NC"
     | 
       ##
       "NEN"
     | 
       ##
       "NSAI"
     | 
       ##
       "ON"
     | 
       ##
       "PKN"
     | 
       ##
       "PSQCA"
     | 
       ##
       "QSAE"
     | 
       ##
       "SA"
     | 
       ##
       "SABS"
     | 
       ##
       "SAC"
     | 
       ##
       "SARM"
     | 
       ##
       "SASO"
     | 
       ##
       "SCC"
     | 
       ##
       "SEE"
     | 
       ##
       "SFS"
     | 
       ##
       "SII"
     | 
       ##
       "SIS"
     | 
       ##
       "SIST"
     | 
       ##
       "SLSI"
     | 
       ##
       "SN"
     | 
       ##
       "SNIMA"
     | 
       ##
       "SNV"
     | 
       ##
       "SNZ"
     | 
       ##
       "SON"
     | 
       ##
       "SPRING-SG"
     | 
       ##
       "SUTN"
     | 
       ##
       "TCVN"
     | 
       ##
       "TISI"
     | 
       ##
       "TSE"
     | 
       ##
       "TTBS"
     | 
       ##
       "UNI"
     | 
       ##
       "UNIT"),
    att.global.attributes,
    empty
  }
idno =
  
  ## (identifier) supplies any form of identifier used to identify some object,
  ##   such as a bibliographic item, a person, a title, an organization,
  ##   etc. in a standardized way.
  element ns6:idno {
    text,
    
    ##
    attribute type {
      
      ##
      "wgNumber"
      | 
        ##
        "serialNumber"
      | 
        ##
        "documentNumber"
      | 
        ##
        "partNumber"
      | 
        ##
        "draftNumber"
      | 
        ##
        "ISO"
      | 
        ##
        "IEC"
      | 
        ##
        "stage"
      | 
        ##
        "supplNumber"
      | 
        ##
        "corrNumber"
      | 
        ##
        "corrType"
      | 
        ##
        "corrYear"
      | 
        ##
        "docNumber"
      | 
        ##
        "docPartNumber"
      | 
        ##
        "documentType"
      | 
        ##
        "parts"
      | 
        ##
        "supplType"
      | 
        ##
        "supplYear"
    }?,
    att.global.attributes,
    empty
  }
availability =
  
  ## supplies information about the availability of a text, for example any restrictions on its
  ##     use or distribution, its copyright status, etc.
  element ns6:availability {
    model.pLike+,
    att.global.attributes,
    att.declarable.attributes,
    
    ## supplies a code identifying the current availability of the text. 
    [ a:defaultValue = "unknown" ]
    attribute status {
      
      ## the text is freely available. 
      "free"
      | 
        ## the status of the text is unknown. 
        "unknown"
      | 
        ## the text is not freely available. 
        "restricted"
    }?,
    empty
  }
seriesStmt =
  
  ## (series statement) groups information about the series, if any, to which a publication belongs.
  element ns6:seriesStmt {
    (model.pLike+
     | (title+, (idno | respStmt)*)),
    att.global.attributes,
    empty
  }
notesStmt =
  
  ## (notes statement) collects together any notes providing information about a text additional to that recorded
  ##     in other parts of the bibliographic description.
  element ns6:notesStmt {
    model.noteLike+, att.global.attributes, empty
  }
model.sourceDescPart = notAllowed
sourceDesc =
  
  ## (source description) describes the source from which an electronic text was derived or generated, typically a
  ##     bibliographic description in the case of a digitized text, or a phrase such as "born digital"
  ##     for a text which has no previous existence.
  element ns6:sourceDesc {
    (model.pLike+
     | (model.biblLike | model.sourceDescPart | model.listLike)+),
    att.global.attributes,
    att.declarable.attributes,
    empty
  }
biblFull =
  
  ## (fully-structured bibliographic citation) contains a fully-structured bibliographic citation, in which all components of the TEI file
  ##     description are present.
  element ns6:biblFull {
    ((titleStmt,
      editionStmt?,
      extent?,
      publicationStmt,
      seriesStmt?,
      notesStmt?),
     sourceDesc*),
    att.global.attributes,
    att.declarable.attributes,
    empty
  }
model.encodingDescPart = projectDesc | refsDecl | classDecl | appInfo
encodingDesc =
  
  ## (encoding description) documents the relationship between an electronic text and the
  ## source or sources from which it was derived.
  element ns6:encodingDesc {
    (model.encodingDescPart | model.pLike)+,
    att.global.attributes,
    empty
  }
projectDesc =
  
  ## (project description) describes in detail the aim or purpose for which an electronic file was encoded, together
  ##     with any other relevant information concerning the process by which it was assembled or
  ##     collected.
  element ns6:projectDesc {
    model.pLike+,
    att.global.attributes,
    att.declarable.attributes,
    empty
  }
refsDecl =
  
  ## (references declaration) specifies how canonical references are constructed for this
  ##   text.
  element ns6:refsDecl {
    model.pLike+,
    att.global.attributes,
    att.declarable.attributes,
    empty
  }
classDecl =
  
  ## (classification declarations) contains one or more taxonomies defining any classificatory
  ## codes used elsewhere in the text.
  element ns6:classDecl { taxonomy+, att.global.attributes, empty }
taxonomy =
  
  ## defines a typology used to classify texts either implicitly, by means of a bibliographic
  ##     citation, or explicitly by a structured taxonomy.
  element ns6:taxonomy {
    (model.glossLike* | category+ | (model.biblLike, category*)),
    att.global.attributes,
    empty
  }
category =
  
  ## contains an individual descriptive category, possibly nested within a superordinate
  ##     category, within a user-defined taxonomy.
  element ns6:category {
    ((catDesc+ | model.glossLike*), category*),
    att.global.attributes,
    empty
  }
catDesc =
  
  ## (category description) describes some category within a taxonomy or text typology, either in the form of a brief
  ##     prose description or in terms of the situational parameters used by the TEI formal textDesc.
  element ns6:catDesc {
    (text | model.limitedPhrase | model.catDescPart)*,
    att.global.attributes,
    empty
  }
appInfo =
  
  ## (application information) records information about an application which has
  ##   edited the TEI file. 
  element ns6:appInfo {
    model.applicationLike+, att.global.attributes, empty
  }
application =
  
  ## provides information about an application which has acted upon the document.
  element ns6:application {
    (model.labelLike*, (model.ptrLike* | model.pLike*)),
    
    ## Supplies an identifier for the application, independent of its version number or display
    ##         name.
    attribute ident { xsd:Name },
    
    ## Supplies a version number for the application, independent of its identifier or display
    ##         name.
    attribute version {
      xsd:token {
        pattern = "[\d]+[a-z]*[\d]*(\.[\d]+[a-z]*[\d]*){0,3}"
      }
    },
    att.global.attributes,
    att.typed.attributes,
    att.datable.attributes,
    empty
  }
model.applicationLike = application
model.profileDescPart = creation | langUsage | textClass
profileDesc =
  
  ## (text-profile description) provides a detailed description of non-bibliographic aspects of a text, specifically the
  ##     languages and sublanguages used, the situation in which it was produced, the participants and
  ##     their setting.
  element ns6:profileDesc {
    model.profileDescPart*, att.global.attributes, empty
  }
creation =
  
  ## contains information about the creation of a text.
  element ns6:creation {
    macro.phraseSeq.limited, att.global.attributes, empty
  }
langUsage =
  
  ## (language usage) describes the languages, sublanguages, registers, dialects, etc.
  ## represented within a text.
  element ns6:langUsage {
    language+, att.global.attributes, att.declarable.attributes, empty
  }
language =
  
  ## characterizes a single language or sublanguage used within a text.
  element ns6:language {
    macro.phraseSeq.limited,
    att.global.attributes,
    
    ## (identifier) Supplies a language code constructed as defined in BCP 47 which is used to identify the
    ##         language documented by this element, and which is referenced by the global
    ##         xml:lang attribute.
    attribute ident { xsd:language },
    
    ## specifies the approximate percentage (by volume) of the text which uses this language. 
    attribute usage {
      xsd:nonNegativeInteger { maxInclusive = "100" }
    }?,
    empty
  }
textClass =
  
  ## (text classification) groups information which describes the nature or topic of a text in terms of a standard
  ##     classification scheme, thesaurus, etc.
  element ns6:textClass {
    (classCode | catRef | keywords)*,
    att.global.attributes,
    att.declarable.attributes,
    empty
  }
keywords =
  
  ## contains a list of keywords or phrases identifying the topic or nature of a text.
  element ns6:keywords {
    (term+ | \list),
    att.global.attributes,
    
    ## identifies the controlled vocabulary within which the set of keywords concerned is
    ##         defined. 
    attribute scheme { xsd:anyURI },
    empty
  }
classCode =
  
  ## (classification code) contains the classification code used for this text in some standard classification system.
  element ns6:classCode {
    macro.phraseSeq.limited,
    att.global.attributes,
    
    ## identifies the classification system or taxonomy in use.
    attribute scheme { xsd:anyURI },
    empty
  }
catRef =
  
  ## (category reference) specifies one or more defined categories within some taxonomy or text typology.
  element ns6:catRef {
    empty,
    att.global.attributes,
    att.pointing.attributes,
    
    ## identifies the classification scheme within which the set of categories concerned is
    ##         defined 
    attribute scheme { xsd:anyURI }?,
    empty
  }
revisionDesc =
  
  ## (revision description) summarizes the revision history for a file.
  element ns6:revisionDesc {
    (\list | change+),
    att.global.attributes,
    att.docStatus.attributes,
    empty
  }
change =
  
  ## summarizes a particular change or correction made to a particular version of an electronic
  ##     text which is shared between several researchers.
  element ns6:change {
    (text | model.limitedPhrase | model.inter | model.global)*,
    att.global.attributes,
    att.ascribed.attributes,
    att.datable.attributes,
    att.docStatus.attributes,
    empty
  }
TEI =
  
  ## (TEI document) contains a single TEI-conformant document,
  ## comprising a TEI header and a text, either in isolation or as part of a
  ## teiCorpus element.
  element ns6:TEI {
    (teiHeader,
     ((model.resourceLike+, \text?) | \text))
    >> sch:ns [ prefix = "tei" uri = "http://www.tei-c.org/ns/1.0" ]
    >> sch:ns [
         prefix = "rng"
         uri = "http://relaxng.org/ns/structure/1.0"
       ],
    att.global.attributes,
    
    ## specifies the version number of the TEI Guidelines against
    ##       which this document is valid.
    [ a:defaultValue = "5.0" ]
    attribute version {
      xsd:token { pattern = "[\d]+(\.[\d]+){0,2}" }
    }?,
    empty
  }
\text =
  
  ## contains a single text of any kind, whether unitary or composite, for example a poem or
  ##     drama, a collection of essays, a novel, a dictionary, or a corpus sample.
  element ns6:text {
    (model.global*,
     (front, model.global*)?,
     (body | group),
     model.global*,
     (back, model.global*)?)
    >> s:ns [ prefix = "i" uri = "http://www.iso.org/ns/1.0" ]
    >> s:ns [ prefix = "tei" uri = "http://www.tei-c.org/ns/1.0" ]
    >> s:pattern [
         name = "text-constraint-isoStructure"
         "\x{a}" ~
         "            "
         s:rule [
           context = "tei:text"
           "\x{a}" ~
           "               "
           s:assert [
             test = "tei:front/tei:div[@type='foreword']"
             "\x{a}" ~
             "		A Foreword clause in the front matter is mandatory"
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ]
    >> s:pattern [
         name = "text-constraint-isoStructure"
         "\x{a}" ~
         "            "
         s:rule [
           context = "tei:text"
           "\x{a}" ~
           "               "
           s:assert [
             test = "tei:body/tei:div[@type='scope']"
             "\x{a}" ~
             "		A Scope clause in the body is mandatory"
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    att.global.attributes,
    att.declaring.attributes,
    att.typed.attributes,
    empty
  }
body =
  
  ## (text body) contains the whole body of a single unitary text, excluding any front or back matter.
  element ns6:body {
    (model.global*,
     (model.divTop, (model.global | model.divTop)*)?,
     (model.divGenLike, (model.global | model.divGenLike)*)?,
     ((model.divLike, (model.global | model.divGenLike)*)+
      | (model.div1Like, (model.global | model.divGenLike)*)+
      | ((model.common, model.global*)+,
         ((model.divLike, (model.global | model.divGenLike)*)+
          | (model.div1Like, (model.global | model.divGenLike)*)+)?)),
     (model.divBottom, model.global*)*),
    att.global.attributes,
    att.declaring.attributes,
    empty
  }
group =
  
  ## contains the body of a composite text, grouping together a sequence of distinct texts (or
  ##     groups of such texts) which are regarded as a unit for some purpose, for example the collected
  ##     works of an author, a sequence of prose essays, etc.
  element ns6:group {
    ((model.divTop | model.global)*,
     ((\text | group), (\text | group | model.global)*),
     model.divBottom*),
    att.global.attributes,
    att.declaring.attributes,
    empty
  }
\div =
  
  ## (text division) contains a subdivision of the front, body, or back of a text.
  element ns6:div {
    ((model.divTop | model.global)*,
     ((((model.divLike | model.divGenLike), model.global*)+
       | ((model.common, model.global*)+,
          ((model.divLike | model.divGenLike), model.global*)*)),
      (model.divBottom, model.global*)*)?)
    >> s:pattern [
         name = "div-constraint-isoDiv"
         "\x{a}" ~
         "            "
         s:rule [
           context = "tei:div"
           "\x{a}" ~
           "               "
           s:assert [
             test = "not(tei:div) or count(tei:div)>1"
             "a clause must contain at least two subclauses"
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    
    ##
    attribute type {
      
      ## Annex
      "annex"
      | 
        ## Annex section
        "annexSection"
      | 
        ## Bibliography
        "bibliography"
      | 
        ## Classification
        "classification"
      | 
        ## Closed
        "closed"
      | 
        ## Foreword
        "foreword"
      | 
        ## No heading
        "headless"
      | 
        ## Introduction
        "introduction"
      | 
        ## Marking
        "marking"
      | 
        ## Normative references
        "normativeReferences"
      | 
        ## Requirements
        "requirements"
      | 
        ## Sampling
        "sampling"
      | 
        ## Scope of standard
        "scope"
      | 
        ## Symbols and terms
        "symbolsAndTerms"
      | 
        ## Terminology Heading
        "termHeading"
      | 
        ## Termsand definitions
        "termsAndDefinitions"
      | 
        ## Test
        "test"
      | 
        ## TOC
        "toc"
    }?,
    att.global.attributes,
    att.divLike.attributes,
    att.typed.attribute.subtype,
    att.declaring.attributes,
    empty
  }
titlePart =
  
  ## contains a subsection or division of the title of a work, as
  ## indicated on a title page.
  element ns6:titlePart {
    macro.paraContent,
    att.global.attributes,
    
    ## specifies the role of this subdivision of the title.
    ## Suggested values include: 1] main; 2] sub(subordinate) ; 3] alt(alternate) ; 4] short; 5] desc(descriptive) 
    [ a:defaultValue = "main" ]
    attribute type {
      
      ## main title of the work
      ##         
      "main"
      | 
        ## (subordinate) subtitle  of the work
        ##         
        "sub"
      | 
        ## (alternate) alternative title  of the work
        ##         
        "alt"
      | 
        ## abbreviated form of title
        "short"
      | 
        ## (descriptive) descriptive paraphrase of the work 
        ##    
        "desc"
      | xsd:Name
    }?,
    empty
  }
front =
  
  ## (front matter) contains any prefatory matter (headers,
  ## title page, prefaces, dedications, etc.)
  ## found  at the start of a document, before the main body.
  element ns6:front {
    ((model.frontPart | model.pLike.front | model.global)*,
     ((model.div1Like,
       (model.frontPart | model.div1Like | model.global)*)
      | (model.divLike,
         (model.frontPart | model.divLike | model.global)*))?,
     (model.divBottomPart, (model.divBottomPart | model.global)*)?),
    att.global.attributes,
    att.declaring.attributes,
    empty
  }
back =
  
  ## (back matter) contains any appendixes, etc. following the main part of a text.
  element ns6:back {
    ((model.frontPart | model.pLike.front | model.global)*,
     ((model.div1Like,
       (model.frontPart | model.div1Like | model.global)*)
      | (model.divLike,
         (model.frontPart | model.divLike | model.global)*))?,
     (model.divBottomPart, (model.divBottomPart | model.global)*)?),
    att.global.attributes,
    att.declaring.attributes,
    empty
  }
table =
  
  ## contains text displayed in tabular form, in rows and columns.
  element ns6:table {
    ((model.headLike | model.global)*, (row, model.global*)+),
    att.global.attributes,
    
    ## indicates the number of rows in the table.
    attribute rows { xsd:nonNegativeInteger }?,
    
    ## (columns) indicates the number of columns in each row of the table.
    attribute cols { xsd:nonNegativeInteger }?,
    empty
  }
row =
  
  ## contains one row of a table. 
  element ns6:row {
    cell+, att.global.attributes, att.tableDecoration.attributes, empty
  }
cell =
  
  ## contains one cell of a table. 
  element ns6:cell {
    macro.paraContent,
    att.global.attributes,
    att.tableDecoration.attributes,
    empty
  }
formula =
  
  ## contains a mathematical or other formula.
  element ns6:formula {
    (macro.xtext
     | model.global
     | model.hiLike
     | model.graphicLike
     | mathml.math)+,
    
    ## supplies the name of a previously defined notation used for the content of the element.
    attribute notation { xsd:anyURI }?,
    att.global.attributes,
    empty
  }
figure =
  
  ## groups elements representing or containing graphic information such as an illustration or
  ##     figure.
  element ns6:figure {
    (model.headLike
     | model.pLike
     | figDesc
     | model.graphicLike
     | model.egLike
     | model.global)*,
    att.global.attributes,
    att.placement.attributes,
    empty
  }
figDesc =
  
  ## (description of figure) contains a brief prose description of the appearance or content
  ## of a graphic figure, for use when documenting an image without
  ## displaying it.
  element ns6:figDesc {
    macro.limitedContent, att.global.attributes, empty
  }
att.global.facs.attributes = att.global.facs.attribute.facs
att.global.facs.attribute.facs =
  
  ## (facsimile) points to all or part of an image which corresponds with the content of the element.
  attribute facs {
    list { xsd:anyURI, xsd:anyURI* }
  }?
addSpan =
  
  ## (added span of text) marks the beginning of a longer sequence of text added by an
  ##   author, scribe, annotator or corrector (see also add).
  element ns6:addSpan {
    empty
    >> sch:pattern [
         id = "addSpan-constraint-spanTo"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "tei:addSpan"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@spanTo"
             "The spanTo= attribute of "
             sch:name [ ]
             " is required."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ]
    >> sch:pattern [
         id = "addSpan-constraint-spanTo_fr"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "tei:addSpan"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@spanTo"
             "L'attribut spanTo est requis."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    att.global.attributes,
    att.datable.attributes,
    att.transcriptional.attributes,
    att.placement.attributes,
    att.typed.attributes,
    att.spanning.attributes,
    empty
  }
delSpan =
  
  ## (deleted span of text) marks the beginning of a longer sequence of text deleted,
  ## marked as deleted, or otherwise signaled as superfluous or spurious by an
  ## author, scribe, annotator, or corrector.
  element ns6:delSpan {
    empty
    >> sch:pattern [
         id = "delSpan-constraint-spanTo"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "tei:delSpan"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@spanTo"
             "The spanTo= attribute of "
             sch:name [ ]
             "\x{a}" ~
             "      is required."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ]
    >> sch:pattern [
         id = "delSpan-constraint-spanTo_fr"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "tei:delSpan"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@spanTo"
             "L'attribut spanTo est requis."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    att.global.attributes,
    att.datable.attributes,
    att.transcriptional.attributes,
    att.typed.attributes,
    att.spanning.attributes,
    empty
  }
fw =
  
  ## (forme work) contains a running head (e.g. a header, footer), catchword, or
  ##   similar material appearing on the current page.
  element ns6:fw {
    (model.inter | model.pLike)+,
    
    ## classifies the material encoded according to some useful typology.
    ## Sample values include: 1] header; 2] footer; 3] pageNum(page number) ; 4] lineNum(line number) ; 5] sig(signature) ; 6] catch(catchword) 
    attribute type { xsd:Name }?,
    att.global.attributes,
    att.placement.attributes,
    empty
  }
orgName =
  
  ## (organization name) contains an organizational name. 
  element ns6:orgName {
    macro.phraseSeq,
    att.global.attributes,
    att.datable.attributes,
    att.editLike.attributes,
    att.personal.attributes,
    att.typed.attributes,
    empty
  }
persName =
  
  ## (personal name) contains a proper noun or proper-noun phrase referring to a person, possibly including any
  ##     or all of the person's forenames, surnames, honorifics, added names, etc.
  element ns6:persName {
    macro.phraseSeq,
    att.global.attributes,
    att.datable.attributes,
    att.editLike.attributes,
    att.personal.attributes,
    att.typed.attributes,
    empty
  }
surname =
  
  ## contains a family (inherited) name, as opposed to a given, baptismal, or nick name.
  element ns6:surname {
    macro.phraseSeq,
    att.global.attributes,
    att.personal.attributes,
    att.typed.attributes,
    empty
  }
forename =
  
  ## contains a forename, given or baptismal name.
  element ns6:forename {
    macro.phraseSeq,
    att.global.attributes,
    att.personal.attributes,
    att.typed.attributes,
    empty
  }
listEvent =
  
  ## (list of events) contains a list of descriptions, each of which provides information
  ##     about an identifiable event. 
  element ns6:listEvent {
    (model.headLike*, listEvent+),
    att.global.attributes,
    att.typed.attributes,
    att.declarable.attributes,
    empty
  }
org =
  
  ## (organization) provides information about an identifiable organization such as a business, a tribe, or
  ##         any other grouping of people.
  element ns6:org {
    (model.headLike*,
     (model.pLike*
      | (model.labelLike | model.nameLike | model.placeLike)*),
     (model.noteLike | model.biblLike)*,
     model.personLike*),
    att.global.attributes,
    att.typed.attributes,
    att.editLike.attributes,
    
    ## specifies a primary role or classification for the organization.
    attribute role {
      list {
        xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" },
        xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" }*
      }
    }?,
    empty
  }
model.persNamePart = surname | forename
model.persNamePart_alternation = surname | forename
model.persNamePart_sequence = surname, forename
model.persNamePart_sequenceOptional = surname?, forename?
model.persNamePart_sequenceOptionalRepeatable = surname*, forename*
model.persNamePart_sequenceRepeatable = surname+, forename+
att.datable.iso.attributes =
  att.datable.iso.attribute.when-iso,
  att.datable.iso.attribute.notBefore-iso,
  att.datable.iso.attribute.notAfter-iso,
  att.datable.iso.attribute.from-iso,
  att.datable.iso.attribute.to-iso
att.datable.iso.attribute.when-iso =
  
  ## supplies the value of a date or time in a standard form.
  attribute when-iso {
    xsd:date
    | xsd:gYear
    | xsd:gMonth
    | xsd:gDay
    | xsd:gYearMonth
    | xsd:gMonthDay
    | xsd:time
    | xsd:dateTime
    | xsd:token { pattern = "[0-9.,DHMPRSTWYZ/:+\-]+" }
  }?
att.datable.iso.attribute.notBefore-iso =
  
  ## specifies the earliest possible date for the event in standard form, e.g. yyyy-mm-dd.
  attribute notBefore-iso {
    xsd:date
    | xsd:gYear
    | xsd:gMonth
    | xsd:gDay
    | xsd:gYearMonth
    | xsd:gMonthDay
    | xsd:time
    | xsd:dateTime
    | xsd:token { pattern = "[0-9.,DHMPRSTWYZ/:+\-]+" }
  }?
att.datable.iso.attribute.notAfter-iso =
  
  ## specifies the latest possible date for the event in standard form, e.g. yyyy-mm-dd.
  attribute notAfter-iso {
    xsd:date
    | xsd:gYear
    | xsd:gMonth
    | xsd:gDay
    | xsd:gYearMonth
    | xsd:gMonthDay
    | xsd:time
    | xsd:dateTime
    | xsd:token { pattern = "[0-9.,DHMPRSTWYZ/:+\-]+" }
  }?
att.datable.iso.attribute.from-iso =
  
  ## indicates the starting point of the period in standard form.
  attribute from-iso {
    xsd:date
    | xsd:gYear
    | xsd:gMonth
    | xsd:gDay
    | xsd:gYearMonth
    | xsd:gMonthDay
    | xsd:time
    | xsd:dateTime
    | xsd:token { pattern = "[0-9.,DHMPRSTWYZ/:+\-]+" }
  }?
att.datable.iso.attribute.to-iso =
  
  ## indicates the ending point of the period in standard form.
  attribute to-iso {
    xsd:date
    | xsd:gYear
    | xsd:gMonth
    | xsd:gDay
    | xsd:gYearMonth
    | xsd:gMonthDay
    | xsd:time
    | xsd:dateTime
    | xsd:token { pattern = "[0-9.,DHMPRSTWYZ/:+\-]+" }
  }?
anchor =
  
  ## (anchor point) attaches an identifier to a point within a text, whether or not it corresponds with a textual element.
  element ns6:anchor {
    empty, att.global.attributes, att.typed.attributes, empty
  }
seg =
  
  ## (arbitrary segment) represents any segmentation of text below the chunk level.
  element ns6:seg {
    macro.paraContent,
    att.global.attributes,
    att.segLike.attributes,
    att.typed.attributes,
    att.responsibility.attributes,
    empty
  }
c =
  
  ## (character) represents a character.
  element ns6:c {
    macro.xtext,
    att.global.attributes,
    att.segLike.attributes,
    att.typed.attributes,
    empty
  }
att.global.analytic.attributes = att.global.analytic.attribute.ana
att.global.analytic.attribute.ana =
  
  ## (analysis) indicates one or more elements containing interpretations of the
  ## element on which the ana attribute appears.
  attribute ana {
    list { xsd:anyURI, xsd:anyURI* }
  }?
att =
  
  ## (attribute) contains the name of an attribute appearing within running text.
  element ns6:att {
    text,
    att.global.attributes,
    
    ## supplies an identifier for the scheme in which this name is defined.
    ## Sample values include: 1] TEI(text encoding initiative) ; 2] DBK(docbook) ; 3] XX(unknown) 
    [ a:defaultValue = "TEI" ] attribute scheme { xsd:Name }?,
    empty
  }
code =
  
  ## contains literal code from some formal language such as a
  ## programming language.
  element ns6:code {
    text,
    att.global.attributes,
    
    ## (formal language) a name identifying the formal language in which  the
    ##	code is expressed
    attribute lang {
      xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" }
    }?,
    empty
  }
eg =
  
  ## (example) contains any kind of illustrative example. 
  element ns6:eg { (text | hi)+, att.global.attributes, empty }
egXML =
  
  ## (example of XML) contains a single well-formed XML fragment demonstrating the use of some XML element or
  ##     attribute, in which the egXML element itself functions as the root element. 
  element ns11:egXML {
    (text | macro.anyXML | anyAlien)+, att.global.attributes, empty
  }
gi =
  
  ## (element name) contains the name (generic identifier) of an element.
  element ns6:gi {
    text,
    att.global.attributes,
    
    ## supplies the name of the scheme in which this name is defined.
    ## Sample values include: 1] TEI(text encoding initiative) ; 2] DBK(docbook) ; 3] XX(unknown) ; 4] Schematron; 5] HTML
    [ a:defaultValue = "TEI" ] attribute scheme { xsd:Name }?,
    empty
  }
ident =
  
  ## (identifier) contains an identifier or name for an object of some kind in a formal language.
  element ns6:ident {
    text, att.global.attributes, att.typed.attributes, empty
  }
tag =
  
  ## contains text of a complete start- or end-tag, possibly including attribute specifications,
  ##     but excluding the opening and closing markup delimiter characters.
  element ns6:tag {
    text,
    att.global.attributes,
    
    ## indicates the type of XML tag intended
    attribute type {
      
      ## a start-tag, with delimiters < and > is intended
      "start"
      | 
        ## an end-tag, with delimiters </ and > is intended
        "end"
      | 
        ## a empty tag, with delimiters < and /> is intended
        "empty"
      | 
        ## a pi (processing instruction), with delimiters <? and ?> is intended
        "pi"
      | 
        ## a comment, with delimiters <!-- and --> is intended
        "comment"
      | 
        ## a marked-section, with delimiters <[CDATA[ and ]]> is intended
        "ms"
    }?,
    
    ## supplies the name of the schema in which this tag is defined.
    [ a:defaultValue = "TEI" ]
    attribute scheme {
      
      ## (text encoding initiative) This tag is defined as part of the TEI scheme.
      "TEI"
      | 
        ## (docbook) this tag is part of the Docbook scheme.
        "DBK"
      | 
        ## (unknown) this tag is part of an unknown scheme.
        "XX"
    }?,
    empty
  }
val =
  
  ## (value) contains a single attribute value.
  element ns6:val { text, att.global.attributes, empty }
specList =
  
  ## (specification list) marks where a list of descriptions is to be inserted into the prose documentation.
  element ns6:specList { specDesc+, att.global.attributes, empty }
specDesc =
  
  ## (specification description) indicates that a description of the specified element or class should be included at this
  ##     point within a document.
  element ns6:specDesc {
    empty,
    att.global.attributes,
    
    ## (identifier) supplies the identifier of the documentary element or class for which a description is
    ##         to be obtained.
    attribute key { xsd:Name }?,
    
    ## (attributes) supplies attribute names for which descriptions should additionally be obtained.
    attribute atts {
      list { xsd:Name* }
    }?,
    empty
  }
elementRef =
  
  ## points to the specification for some element which is to be included in a schema
  element ns6:elementRef {
    empty,
    att.global.attributes,
    att.readFrom.attributes,
    
    ## the identifier used for the required element within the
    ##	source indicated.
    attribute key { xsd:NCName },
    empty
  }
macroRef =
  
  ## points to the specification for some pattern which is to be included in a schema
  element ns6:macroRef {
    empty,
    att.global.attributes,
    att.readFrom.attributes,
    
    ## the identifier used for the required pattern within the
    ##	source indicated.
    attribute key { xsd:NCName },
    empty
  }
moduleRef =
  
  ## (module reference) references a module which is to be incorporated into a schema.
  element ns6:moduleRef {
    (content?)
    >> sch:pattern [
         id = "moduleRef-constraint-modref"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "tei:moduleRef"
           "\x{a}" ~
           "                              "
           sch:report [
             test = "* and @key"
             "\x{a}" ~
             "	  child elements of moduleRef are only allowed when an external module\x{a}" ~
             "	  is being loaded\x{a}" ~
             "	"
           ]
           "\x{a}" ~
           "                           "
         ]
         "\x{a}" ~
         "         "
       ],
    att.global.attributes,
    att.readFrom.attributes,
    (
     ## supplies a list of the elements which are to be copied from the
     ## specified module into the schema being defined.
     attribute include {
       list { xsd:NCName* }
     }?
     | 
       ## supplies a list of the elements which are not to be copied from the
       ## specified module into the schema being defined.
       attribute except {
         list { xsd:NCName* }
       }?),
    (
     ## the name of a TEI module
     attribute key { xsd:NCName }?
     | 
       ## (uniform resource locator) refers to a non-TEI module of RELAX NG code by external location 
       attribute url { xsd:anyURI }?),
    empty
  }
moduleSpec =
  
  ## (module specification) documents the structure, content, and purpose of a single
  ## module, i.e. a named and externally visible group of declarations.
  element ns6:moduleSpec {
    (model.glossLike*, exemplum*, remarks?, listRef*),
    att.global.attributes,
    att.identified.attributes,
    
    ## type of module to be generated
    attribute type { text }?,
    empty
  }
schemaSpec =
  
  ## (schema specification) generates a TEI-conformant schema and documentation for it.
  element ns6:schemaSpec {
    (model.glossLike*,
     (model.oddRef | model.oddDecl)*,
     constraintSpec*),
    att.global.attributes,
    att.identified.attributes,
    att.readFrom.attributes,
    
    ## specifies entry points to the schema, i.e. which elements
    ##       may be used as the root of documents conforming to
    ##       it. 
    [ a:defaultValue = "TEI" ]
    attribute start {
      list { xsd:Name, xsd:Name* }
    }?,
    
    ## (namespace) specifies the default namespace (if any) applicable to 
    ##       components of the schema.
    [ a:defaultValue = "http://www.tei-c.org/ns/1.0" ]
    attribute ns { xsd:anyURI }?,
    
    ## specifies a default prefix which will be appended to all patterns
    ##       relating to TEI elements, unless otherwise stated. This allows for external schemas to be mixed in
    ##       which have elements of the same names as the TEI.
    ##       
    attribute prefix { "" | xsd:Name }?,
    
    ## (target language) specifies which language to use when creating
    ##       the objects in a schema if names for elements or attributes are available in more
    ##       than one language, .
    attribute targetLang { xsd:language }?,
    
    ## (documentation language) specifies which languages to
    ##       use when creating documentation if  the description for an element, attribute, class or macro
    ##       is available in more than one language, .
    attribute docLang {
      list { xsd:language, xsd:language* }
    }?,
    empty
  }
specGrp =
  
  ## (specification group) contains any convenient grouping of specifications for use within
  ##   the current module.
  element ns6:specGrp {
    (model.oddDecl | model.oddRef | model.divPart)*,
    att.global.attributes,
    empty
  }
specGrpRef =
  
  ## (reference to a specification group) indicates that the declarations contained by the specGrp referenced should be
  ##     inserted at this point.
  element ns6:specGrpRef {
    empty,
    att.global.attributes,
    
    ## points at the specification group which logically belongs here.
    attribute target { xsd:anyURI },
    empty
  }
stringVal =
  
  ## contains the intended expansion for the entity documented by a macroSpec element,
  ##     enclosed by quotation marks.
  element ns6:stringVal { text, att.global.attributes, empty }
elementSpec =
  
  ## (element specification) documents the structure, content, and purpose of a single element type.
  element ns6:elementSpec {
    (model.glossLike*,
     classes?,
     content?,
     valList?,
     constraintSpec*,
     attList?,
     exemplum*,
     remarks*,
     listRef*),
    att.global.attributes,
    att.identified.attributes,
    
    ## (namespace) specifies the namespace to which this element belongs
    [ a:defaultValue = "http://www.tei-c.org/ns/1.0" ]
    attribute ns { xsd:anyURI }?,
    empty
  }
classSpec =
  
  ## (class specification) contains reference information for a TEI element class; 
  ## that is a group of 
  ##   elements which appear together in  content models, or 
  ##   which share some common attribute, or both.
  element ns6:classSpec {
    (model.glossLike*,
     classes?,
     constraintSpec*,
     attList?,
     exemplum*,
     remarks*,
     listRef*),
    att.global.attributes,
    att.identified.attributes,
    
    ## indicates whether this is a model class or an attribute class
    attribute type {
      
      ## (content model) members of this class appear in the same  content models
      "model"
      | 
        ## (attributes) members of this class share common attributes
        "atts"
    },
    
    ## indicates which alternation and sequence instantiations
    ##	of a model class may be referenced. By default, all variations
    ##	are permitted.
    attribute generate {
      list {
        (
         ## members of the class are alternatives
         "alternation"
         | 
           ## members of the class are to be provided in sequence
           "sequence"
         | 
           ## members of the class may be provided, in sequence,
           ##	    but are optional
           "sequenceOptional"
         | 
           ## members of the class may be provided one or more
           ##	    times, in sequence, but are optional. 
           "sequenceOptionalRepeatable"
         | 
           ## members of the class may be provided one or more times, in sequence
           "sequenceRepeatable"),
        (
         ## members of the class are alternatives
         "alternation"
         | 
           ## members of the class are to be provided in sequence
           "sequence"
         | 
           ## members of the class may be provided, in sequence,
           ##	    but are optional
           "sequenceOptional"
         | 
           ## members of the class may be provided one or more
           ##	    times, in sequence, but are optional. 
           "sequenceOptionalRepeatable"
         | 
           ## members of the class may be provided one or more times, in sequence
           "sequenceRepeatable")?,
        (
         ## members of the class are alternatives
         "alternation"
         | 
           ## members of the class are to be provided in sequence
           "sequence"
         | 
           ## members of the class may be provided, in sequence,
           ##	    but are optional
           "sequenceOptional"
         | 
           ## members of the class may be provided one or more
           ##	    times, in sequence, but are optional. 
           "sequenceOptionalRepeatable"
         | 
           ## members of the class may be provided one or more times, in sequence
           "sequenceRepeatable")?,
        (
         ## members of the class are alternatives
         "alternation"
         | 
           ## members of the class are to be provided in sequence
           "sequence"
         | 
           ## members of the class may be provided, in sequence,
           ##	    but are optional
           "sequenceOptional"
         | 
           ## members of the class may be provided one or more
           ##	    times, in sequence, but are optional. 
           "sequenceOptionalRepeatable"
         | 
           ## members of the class may be provided one or more times, in sequence
           "sequenceRepeatable")?,
        (
         ## members of the class are alternatives
         "alternation"
         | 
           ## members of the class are to be provided in sequence
           "sequence"
         | 
           ## members of the class may be provided, in sequence,
           ##	    but are optional
           "sequenceOptional"
         | 
           ## members of the class may be provided one or more
           ##	    times, in sequence, but are optional. 
           "sequenceOptionalRepeatable"
         | 
           ## members of the class may be provided one or more times, in sequence
           "sequenceRepeatable")?
      }
    }?,
    empty
  }
macroSpec =
  
  ## (macro specification) documents the function and implementation of a pattern. 
  element ns6:macroSpec {
    (model.glossLike*,
     (stringVal | content)*,
     exemplum*,
     remarks*,
     listRef*),
    att.global.attributes,
    att.identified.attributes,
    
    ## indicates which type of entity should be generated, when an ODD
    ##	processor is generating a module using XML DTD syntax.
    attribute type {
      
      ## (parameter entity) 
      "pe"
      | 
        ## (datatype entity) 
        "dt"
    }?,
    empty
  }
remarks =
  
  ## contains any commentary or discussion about the usage of an element, attribute, class, or
  ##     entity not otherwise documented within the containing element.
  element ns6:remarks {
    model.pLike+,
    att.global.attributes,
    att.translatable.attributes,
    empty
  }
listRef =
  
  ## (list of references) supplies a list of significant references to places where this element is discussed, in the
  ##     current document or elsewhere.
  element ns6:listRef { ptr+, att.global.attributes, empty }
exemplum =
  
  ## groups an example demonstrating the use of an element along with optional paragraphs of
  ##     commentary.
  element ns6:exemplum {
    (model.pLike*, (egXML | eg), model.pLike*),
    att.global.attributes,
    att.typed.attributes,
    att.translatable.attributes,
    empty
  }
classes =
  
  ## specifies all the classes of which the documented element or
  ## class is a member or subclass.
  element ns6:classes {
    memberOf*,
    att.global.attributes,
    
    ## specifies the effect of this declaration on its parent
    ##     module.
    [ a:defaultValue = "replace" ]
    attribute mode {
      
      ## this declaration changes the declaration of the same
      ##     name in the current definition
      "change"
      | 
        ## this declaration replaces the declaration of the same
        ##     name in the current definition
        "replace"
    }?,
    empty
  }
memberOf =
  
  ## specifies class membership of the parent element or class.
  element ns6:memberOf {
    macro.xtext,
    att.global.attributes,
    
    ## specifies the identifier for a class of which the documented element or class is a
    ##         member or subclass
    attribute key { xsd:Name }?,
    
    ## specifies the effect of this declaration on its parent module.
    [ a:defaultValue = "add" ]
    attribute mode {
      
      ## this declaration is added to the current definitions
      "add"
      | 
        ## this declaration and all of its children are removed from the current setup
        "delete"
    }?,
    empty
  }
equiv =
  
  ## (equivalent) specifies a component which is considered equivalent to the parent element, either by
  ##     co-reference, or by external link.
  element ns6:equiv {
    empty,
    att.global.attributes,
    att.internetMedia.attributes,
    
    ## names the underlying concept of which the parent is a representation
    attribute name { xsd:Name }?,
    
    ## (uniform resource identifier) references the underlying concept of which the parent is a representation by means of
    ##         some external identifier
    attribute uri { xsd:anyURI }?,
    
    ## references an external script which contains a method to transform instances of this
    ##         element to canonical TEI 
    attribute filter { xsd:anyURI }?,
    empty
  }
altIdent =
  
  ## (alternate identifier) supplies the recommended XML name for an element, class,
  ##   attribute, etc. in some language.
  element ns6:altIdent {
    macro.xtext, att.global.attributes, att.typed.attributes, empty
  }
content =
  
  ## (content model) contains the text of a declaration for the schema
  ## documented.
  element ns6:content {
    macro.schemaPattern*,
    att.global.attributes,
    
    ## controls whether or not pattern names generated in the
    ## corresponding RELAXNG schema source are automatically prefixed to
    ## avoid potential nameclashes. 
    [ a:defaultValue = "true" ]
    attribute autoPrefix {
      
      ## Each name referenced in e.g. a rng:ref
      ##	  element within a content model is automatically prefixed by
      ##	  the value of the prefix attribute on the current
      ##	  schemaSpec
      ##                                  
      "true"
      | 
        ## No prefixes are added: 
        ##  any prefix required by the value of the prefix attribute on the current
        ##	  schemaSpec must therefore be supplied explicitly, as appropriate. 
        "false"
    }?,
    empty
  }
constraint =
  
  ##  (constraint rules) the formal rules of a constraint
  element ns6:constraint {
    (text | macro.anyXML), att.global.attributes, empty
  }
constraintSpec =
  
  ##  (constraint on schema) contains  a constraint, expressed in some formal syntax,
  ##   which cannot be expressed in the structural content model
  element ns6:constraintSpec {
    model.glossLike*,
    (constraint?)
    >> sch:ns [
         prefix = "s"
         uri = "http://www.ascc.net/xml/schematron"
       ]
    >> sch:pattern [
         id = "constraintSpec-constraint-sch"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "tei:constraintSpec"
           "\x{a}" ~
           "               "
           sch:report [
             test =
               "tei:constraint/s:* and    not(@scheme='schematron')"
             "\x{a}" ~
             "	Rules in the Schematron 1.* language must be inside\x{a}" ~
             "	a constraint with a value of 'schematron' on the scheme attribute\x{a}" ~
             "      "
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ]
    >> sch:ns [
         prefix = "sch"
         uri = "http://purl.oclc.org/dsdl/schematron"
       ]
    >> sch:pattern [
         id = "constraintSpec-constraint-isosch"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "tei:constraintSpec"
           "\x{a}" ~
           "               "
           sch:report [
             test =
               "tei:constraint/sch:* and    not(@scheme='isoschematron')"
             "\x{a}" ~
             "	Rules in the ISO Schematron language must be inside\x{a}" ~
             "	a constraint with a value of 'isoschematron' on the scheme attribute\x{a}" ~
             "      "
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    att.global.attributes,
    att.identified.attributes,
    att.typed.attributes,
    
    ## supplies the name of the language in which the constraints
    ##       are defined
    attribute scheme {
      
      ##  (Schematron) 
      "schematron"
      | 
        ##  (ISO Schematron) 
        "isoschematron"
      | 
        ##  (XSLT) 
        "xsl"
      | 
        ##  (private constraint language) 
        "private"
    },
    empty
  }
attList =
  
  ## contains documentation for all the attributes associated with this element, as a series of
  ##       attDef elements.
  element ns6:attList {
    (attRef | attDef | attList)+,
    att.global.attributes,
    
    ## (organization) specifies whether all the attributes in the list are available (org="group") or only one
    ##         of them (org="choice")
    [ a:defaultValue = "group" ]
    attribute org {
      
      ## grouped
      "group"
      | 
        ## alternated
        "choice"
    }?,
    empty
  }
attDef =
  
  ## (attribute definition) contains the definition of a single attribute.
  element ns6:attDef {
    (model.glossLike*,
     datatype?,
     constraintSpec*,
     defaultVal?,
     (valList | valDesc+)?,
     exemplum*,
     remarks*),
    att.global.attributes,
    att.identified.attributes,
    
    ## specifies the optionality of an attribute or element. 
    [ a:defaultValue = "opt" ]
    attribute usage {
      
      ## (required) 
      "req"
      | 
        ## (mandatory when applicable ) 
        "mwa"
      | 
        ## (recommended ) 
        "rec"
      | 
        ## (recommended when applicable ) 
        "rwa"
      | 
        ## (optional ) 
        "opt"
    }?,
    
    ## (namespace) specifies the namespace to which this attribute belongs
    [ a:defaultValue = "http://www.tei-c.org/ns/1.0" ]
    attribute ns { xsd:anyURI }?,
    empty
  }
attRef =
  
  ## (attribute pointer) points to the definition of an attribute or group of attributes.
  element ns6:attRef {
    empty,
    att.global.attributes,
    
    ## the name of the pattern defining the attribute(s)
    attribute name {
      xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" }
    },
    empty
  }
datatype =
  
  ## specifies the declared value for an attribute, by referring to
  ##   any datatype defined by the chosen schema language.
  element ns6:datatype {
    macro.schemaPattern*,
    att.global.attributes,
    
    ## (minimum number of occurences) indicates the minimum number of times this datatype may
    ##       occur in the specification of the attribute being defined
    [ a:defaultValue = "1" ]
    attribute minOccurs { xsd:nonNegativeInteger }?,
    
    ## (maximum number of occurences) indicates the maximum number of times this datatype may
    ##       occur in the specification of the attribute being defined
    [ a:defaultValue = "1" ]
    attribute maxOccurs { xsd:nonNegativeInteger | "unbounded" }?,
    empty
  }
defaultVal =
  
  ## (default value) specifies the default declared value for an attribute.
  element ns6:defaultVal { text, att.global.attributes, empty }
valDesc =
  
  ## (value description) specifies any semantic or syntactic constraint on the value that
  ## an attribute may take, additional to the information carried by the
  ## datatype element.
  element ns6:valDesc {
    macro.phraseSeq.limited,
    att.global.attributes,
    att.translatable.attributes,
    att.combinable.attributes,
    empty
  }
valItem =
  
  ## documents a single attribute-value within a list of possible
  ##   or mandatory items.
  element ns6:valItem {
    model.glossLike*,
    att.global.attributes,
    att.combinable.attributes,
    
    ## specifies the attribute value concerned.
    attribute ident { text },
    empty
  }
valList =
  
  ## (value list) contains one or more valItem elements defining possible values for an attribute.
  element ns6:valList {
    valItem*,
    att.global.attributes,
    att.combinable.attributes,
    
    ## specifies the extensibility of the list of attribute values specified. 
    [ a:defaultValue = "open" ]
    attribute type {
      
      ## only the values specified are permitted.
      "closed"
      | 
        ## (semi-open) all the values specified should be supported, but other values are legal and
        ##             software should have appropriate fallback processing for them. 
        "semi"
      | 
        ## the values specified are sample values only.
        "open"
    }?,
    empty
  }
att.combinable.attributes = att.combinable.attribute.mode
att.combinable.attribute.mode =
  
  ## specifies the effect of this declaration on its parent
  ##     object.
  [ a:defaultValue = "add" ]
  attribute mode {
    
    ## this declaration is added to the current definitions
    "add"
    | 
      ## if present already, the whole of the declaration 
      ##	  for this object is  removed from the current setup
      "delete"
    | 
      ## this declaration changes the declaration of the same
      ##     name in the current definition
      "change"
    | 
      ## this declaration replaces the declaration of the same
      ##     name in the current definition
      "replace"
  }?
att.identified.attributes =
  att.combinable.attributes,
  att.identified.attribute.ident,
  att.identified.attribute.predeclare,
  att.identified.attribute.module
att.identified.attribute.ident =
  
  ## Supplies the identifier by which this element may be referenced.
  attribute ident { xsd:Name }
att.identified.attribute.predeclare =
  
  ## Says whether this object should be predeclared in the
  ##       tei infrastructure module.
  [ a:defaultValue = "false" ] attribute predeclare { xsd:boolean }?
att.identified.attribute.module =
  
  ## Supplies a name for the module in which this object is to
  ##       be declared.
  attribute module { xsd:NCName }?
idlang.attributes = id.attributes, lang.attributes
id.attributes = id.attribute.id
id.attribute.id =
  
  ##
  attribute id { text }?
target-IDREF.attributes = target-IDREF.attribute.target
target-IDREF.attribute.target =
  
  ##
  attribute target { text }?
lang.attributes = lang.attribute.xmllang
lang.attribute.xmllang =
  
  ## Indicates the language of the element content. The allowed values are
  ##							found in IETF RFC 4646 or its successor. This attribute is optional for
  ##							elements that use this attribute class. For a description, see the
  ##							information at the martif element.
  attribute xml:lang { text }?
IDLangTgtDtyp.attributes =
  lang.attributes,
  id.attributes,
  target-IDREF.attributes,
  IDLangTgtDtyp.attribute.datatype
IDLangTgtDtyp.attribute.datatype =
  
  ## The data type of plainText, or what is known as PCDATA.
  attribute datatype { text }?
wordObject =
  
  ## Any Word-specific chunk of XML code
  element i:wordObject { (anyOOXML | anyOLE | anyVML)+, empty }
footer =
  
  ##
  element ns3:footer {
    empty,
    
    ##
    attribute type { text }?,
    
    ##
    attribute ref { text }?,
    empty
  }
dynamicContent =
  
  ##
  element ns3:dynamicContent {
    empty,
    
    ##
    attribute type { text }?,
    empty
  }
orientation =
  
  ##
  element ns3:orientation {
    empty,
    
    ##
    attribute type { text }?,
    empty
  }
pageNumbering =
  
  ##
  element ns3:pageNumbering {
    empty,
    
    ##
    attribute type { text }?,
    
    ##
    attribute start { text }?,
    empty
  }
header =
  
  ##
  element ns3:header {
    empty,
    
    ##
    attribute type { text }?,
    
    ##
    attribute ref { text }?,
    empty
  }
calstable =
  
  ##
  element ns5:table {
    calstabletitle?,
    tgroup+,
    
    ##
    attribute ns6:corresp { xsd:anyURI }?,
    
    ##
    attribute i:style { text }?,
    
    ##
    attribute xml:id { xsd:ID }?,
    
    ##
    attribute frame {
      
      ##
      "top"
      | 
        ##
        "bottom"
      | 
        ##
        "topbot"
      | 
        ##
        "all"
      | 
        ##
        "sides"
      | 
        ##
        "none"
    }?,
    
    ##
    attribute colsep { yesorno }?,
    
    ##
    attribute rowsep { yesorno }?,
    empty
  }
tgroup =
  
  ##
  element ns5:tgroup {
    colspec*,
    thead?,
    tbody,
    
    ##
    attribute cols { xsd:NMTOKEN }?,
    
    ##
    attribute colsep { yesorno }?,
    
    ##
    attribute rowsep { yesorno }?,
    
    ##
    attribute align {
      
      ##
      "left"
      | 
        ##
        "right"
      | 
        ##
        "center"
      | 
        ##
        "justify"
      | 
        ##
        "char"
    }?,
    empty
  }
colspec =
  
  ##
  element ns5:colspec {
    empty,
    
    ##
    attribute colnum { xsd:NMTOKEN }?,
    
    ##
    attribute colname { xsd:NMTOKEN }?,
    
    ##
    attribute colwidth { text }?,
    
    ##
    attribute colsep { yesorno }?,
    
    ##
    attribute rowsep { yesorno }?,
    
    ##
    attribute align {
      
      ##
      "left"
      | 
        ##
        "right"
      | 
        ##
        "center"
      | 
        ##
        "justify"
      | 
        ##
        "char"
    }?,
    
    ##
    attribute char { text }?,
    
    ##
    attribute charoff { xsd:NMTOKEN }?,
    empty
  }
calstabletitle =
  
  ##
  element ns5:title {
    macro.paraContent,
    
    ##
    attribute xml:id { xsd:ID }?,
    empty
  }
thead =
  
  ##
  element ns5:thead {
    calsrow+,
    
    ##
    attribute valign {
      
      ##
      "top"
      | 
        ##
        "middle"
      | 
        ##
        "bottom"
    }?,
    empty
  }
tbody =
  
  ##
  element ns5:tbody {
    calsrow+,
    
    ##
    attribute valign {
      
      ##
      "top"
      | 
        ##
        "middle"
      | 
        ##
        "bottom"
    }?,
    empty
  }
calsrow =
  
  ##
  element ns5:row {
    entry+,
    
    ##
    attribute i:style { text }?,
    
    ##
    attribute rowsep { yesorno }?,
    
    ##
    attribute valign {
      
      ##
      "top"
      | 
        ##
        "middle"
      | 
        ##
        "bottom"
    }?,
    empty
  }
entry =
  
  ##
  element ns5:entry {
    (p | macro.paraContent)+,
    
    ##
    attribute i:style { text }?,
    
    ##
    attribute colname { xsd:NMTOKEN }?,
    
    ##
    attribute namest { xsd:NMTOKEN }?,
    
    ##
    attribute nameend { xsd:NMTOKEN }?,
    
    ##
    attribute morerows { xsd:NMTOKEN }?,
    
    ##
    attribute colsep { yesorno }?,
    
    ##
    attribute rowsep { yesorno }?,
    
    ##
    attribute rotate { yesorno }?,
    
    ##
    attribute align {
      
      ##
      "left"
      | 
        ##
        "right"
      | 
        ##
        "center"
      | 
        ##
        "justify"
      | 
        ##
        "char"
    }?,
    
    ##
    attribute char { text }?,
    
    ##
    attribute charoff { xsd:NMTOKEN }?,
    
    ##
    attribute valign {
      
      ##
      "top"
      | 
        ##
        "middle"
      | 
        ##
        "bottom"
    }?,
    empty
  }
tbx_admin =
  
  ## Contains information of an administrative nature for the node (parent element)
  ##					in question, such as the source of information, or the project or client for
  ##					which it applies. The type of administrative information is indicated by the
  ##					value of the type attribute. It can appear alone, or, if additional
  ##					information needs to be provided, such as a note or a reference, it can be
  ##					nested in an adminGrp element. This element can occur at any of
  ##						the three levels of the terminological entry. Several types, however,
  ##						logically should occur at restricted levels, as indicated with the
  ##						corresponding data-category descriptions. For instance,
  ##						databaseType and conceptOrigin would typically occur
  ##						at the termEntry level. Care should be taken to insert the admin at
  ##						the appropriate level of the entry according to its type attribute value and
  ##						the parent node to which the administrative information applies.
  ##                      
  element admin {
    tbx_entity.noteText
    >> s:pattern [
         name = "admin_applicationSubset"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:admin[@type='applicationSubset']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test = ".=not(*)"
             "The application subset must be expressed in\x{a}" ~
             "								plainText."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "admin_businessUnitSubset"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:admin[@type='businessUnitSubset']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test = ".=not(*)"
             "The business unit subset must be expressed\x{a}" ~
             "								in plainText."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "admin_conceptOrigin"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:admin[@type='conceptOrigin']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test = ".=not(*)"
             "The concept origin must be expressed in\x{a}" ~
             "								plainText."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "admin_customerSubset"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:admin[@type='customerSubset']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test = ".=not(*)"
             "The customer subset must be expressed in\x{a}" ~
             "								plainText."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "admin_databaseType"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:admin[@type='databaseType']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test = ".=not(*)"
             "The type of data base must be expressed in\x{a}" ~
             "								plainText."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "admin_domainExpert"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:admin[@type='domainExpert']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test = ".=not(*)"
             "The domain expert must be expressed in plain\x{a}" ~
             "								text."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "admin_elementWorkingStatus"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:admin[@type='elementWorkingStatus']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test =
               ".='starterElement' or .='workingElement' or .='consolidatedElement' or .='archiveElement' or .='importedElement' or .='exportedElement'"
             " The element working status must be starterElement, workingElement,\x{a}" ~
             "								consolidatedElement, archiveElement, importedElement, or\x{a}" ~
             "								exportedElement."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "admin_entrySource"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:admin[@type='entrySource']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test = ".=not(*)"
             "The source of the entry must be expressed in\x{a}" ~
             "								plainText."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "admin_environmentSubset"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:admin[@type='environmentSubset']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test = ".=not(*)"
             "The environment subset must be expressed in\x{a}" ~
             "								plainText."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "admin_indexHeading"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:admin[@type='indexHeading']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test = ".=not(*)"
             "The index heading must be expressed in plain\x{a}" ~
             "								text."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "admin_keyword"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:admin[@type='keyword']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test = ".=not(*)"
             "The keyword must be expressed in plain\x{a}" ~
             "							text."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "admin_originatingPerson"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:admin[@type='originatingPerson']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test = ".=not(*)"
             "The name of the originating person must be\x{a}" ~
             "								expressed in plainText."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "admin_originatingDatabase"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:admin[@type='originatingDatabase']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test = ".=not(*)"
             "The name of the originating database must be\x{a}" ~
             "								expressed in plainText."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "admin_originatingInstitution"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:admin[@type='originatingInstitution']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test = ".=not(*)"
             "The name of the originating institution must\x{a}" ~
             "								be expressed in plainText."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "admin_productSubset"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:admin[@type='productSubset']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test = ".=not(*)"
             "The product subset must be expressed in\x{a}" ~
             "								plainText."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "admin_projectSubset"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:admin[@type='projectSubset']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test = ".=not(*)"
             "The project subset must be expressed in\x{a}" ~
             "								plainText."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "admin_securitySubset"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:admin[@type='securitySubset']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test = ".='public' or .='confidential'"
             "The security subset\x{a}" ~
             "								must be public or confidential."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "admin_searchTerm"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:admin[@type='searchTerm']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test = ".=not(*)"
             "The search term must be expressed in plain\x{a}" ~
             "								text."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "admin_sourceIdentifier"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:admin[@type='sourceIdentifier']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test = ".=not(*)"
             "The source identifier must be expressed in\x{a}" ~
             "								plainText."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "admin_sortKey"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:admin[@type='sortKey']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test = ".=not(*)"
             "The sort key must be expressed in\x{a}" ~
             "							plainText."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "admin_subsetOwner"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:admin[@type='subsetOwner']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test = ".=not(*)"
             "The name of the subset owner must be\x{a}" ~
             "								expressed in plainText."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ],
    IDLangTgtDtyp.attributes,
    
    ## Indicates the data-category type of the admin element, such
    ##							as originatingDatabase or entrySource.
    attribute type {
      
      ##  (annotatedNote) A note that can be coupled with an adminNote element
      ##									to indicate the source of the note or other administrative
      ##									information about the note. If no source or additional
      ##									information about the note is required, use the note
      ##									element.
      "annotatedNote"
      | 
        ##  (applicationSubset) An identifier that indicates that the parent element to which
        ##									it applies is associated with a specific application. The
        ##									content shall be in plainText.
        "applicationSubset"
      | 
        ##  (businessUnitSubset) An identifier that indicates that the parent element to which
        ##									it applies is associated with a specific department, division,
        ##									or other unit of an enterprise. The content shall be in
        ##									plainText.
        "businessUnitSubset"
      | 
        ##  (conceptOrigin) The institution, region, community, culture, country, or other
        ##									venue from which a concept covered by a terminological entry
        ##									originates. Because this data-category provides information
        ##									about the origin of the concept, it should occur at the
        ##										termEntry level. The content shall be in
        ##								plainText.
        "conceptOrigin"
      | 
        ##  (customerSubset) An identifier that indicates that the parent element to which
        ##									it applies is associated with a specific customer. The content
        ##									shall be in plainText.
        "customerSubset"
      | 
        ##  (databaseType) An identifier that indicates the type of database from which
        ##									the parent element originated. This element should normally
        ##									occur at the termEntry level because typically entire
        ##									entries originate from or are imported from another database.
        ##									The content shall be in plainText.
        "databaseType"
      | 
        ##  (domainExpert) Subject field specialist who provides information for a
        ##									terminological entry, such as a definition or target language
        ##									equivalent. An admin element that has a type
        ##									attribute value of domainExpert can also have a
        ##										target attribute pointing to the identifier of a
        ##									reference entry in the back matter of the TBX document instance
        ##									that provides information about the domain expert. The content
        ##									shall be in plainText.
        "domainExpert"
      | 
        ##  (elementWorkingStatus) A value indicating the level of completeness and accuracy of
        ##									an element (field, record, entry) within a terminological
        ##									collection. The element admin when its type
        ##									attribute has the value elementWorkingStatus shall
        ##									contain one of the following values:
        ##										                              * starterElement
        ##										                              * workingElement
        ##										                              * consolidatedElement
        ##										                              * archiveElement
        ##										                              * importedElement
        ##										                              * exportedElement
        ## 
        ##									                           
        ##                                  
        "elementWorkingStatus"
      | 
        ##  (entrySource) A database or file from which the entry was imported. The
        ##									content shall be in plainText. 
        ##									
        "entrySource"
      | 
        ##  (environmentSubset) An identifier that indicates a specific computer environment
        ##									that the parent element is associated with. The content shall be
        ##									in plainText.
        "environmentSubset"
      | 
        ##  (indexHeading) A term chosen to be used in an index to represent an item or a
        ##									concept in a document. The content shall be in plainText.
        "indexHeading"
      | 
        ##  (keyword) A word or group of words, possibly in lexicographically
        ##									standardized (lemmatized) form, taken out of the text of a
        ##									document, which characterizes the text and enables its
        ##									retrieval. For example, the terms data-category and
        ##										terminological entry are keywords for this
        ##									international standard. In a terminological database that
        ##									contains the terminology of ISO 30042, they could be identified
        ##									as keywords by using this element. The content shall be in
        ##									plainText.
        "keyword"
      | 
        ##  (originatingDatabase) The database from which the parent element originated. The
        ##									content shall be in plainText.
        "originatingDatabase"
      | 
        ##  (originatingInstitution) An institution (i.e., company, government agency, etc.) that
        ##									provided the information in the parent element. The content
        ##									shall be in plainText.
        "originatingInstitution"
      | 
        ##  (originatingPerson) An individual who provided the information in the parent
        ##									element. The content shall be in plainText.
        "originatingPerson"
      | 
        ##  (productSubset) An identifier assigned to a term, record, or entry to indicate
        ##									that it is related to or used in a product. The content shall be
        ##									in plainText, and preferably one of a predefined set of picklist
        ##									values.
        "productSubset"
      | 
        ##  (projectSubset) An identifier assigned to a term, record, or entry to indicate
        ##									that it is related to or used in a project. The content shall be
        ##									in plainText, and preferably one of a predefined set of picklist
        ##									values.
        "projectSubset"
      | 
        ##  (searchTerm) A term entered in a term entry for purposes of retrieval. The
        ##									content shall be in plainText
        ##									
        "searchTerm"
      | 
        ##  (securitySubset) A classification of a term, record, or entry indicating that
        ##									its distribution is restricted for security reasons. Sometimes,
        ##									terms are not released to the public until the material that
        ##									uses the term (product, service, etc.) is released to the
        ##									public. Until that time, this element serves to protect the data
        ##									from distribution. The element admin when its
        ##									type attribute has the value
        ##									securitySubset shall contain one of the following values:
        ##										                              * public
        ##										                              * confidential
        ##									                           
        ##                                  
        "securitySubset"
      | 
        ##  (sortKey) A character string used for sorting and merging operations. A
        ##									sort key can enable alphabetic or systematic access. The content
        ##									shall be in plainText.
        "sortKey"
      | 
        ##  (source) A complete citation of the source of the information in the
        ##									parent element.
        ##									
        "source"
      | 
        ##  (sourceIdentifier) A pointer to a bibliographic entry that contains information
        ##									about the source of the parent element. An admin
        ##									element that has a type attribute value of
        ##										sourceIdentifier also has a target
        ##									attribute containing the identifier of the bibliographic entry.
        ##									The content of the element is a display value for the
        ##								source.
        "sourceIdentifier"
      | 
        ##  (subsetOwner) The owner of the subset of terminological entries to which
        ##									this entry belongs. The content shall be in plainText.
        "subsetOwner"
    },
    empty
  }
tbx_descrip =
  
  ## An element that contains descriptive information about a concept, or relations
  ##					to other concepts. The type of information that the element contains, and any
  ##					restrictions on the permissible values of the element, are determined by the
  ##					value of the type attribute.
  element descrip {
    ((text | tbx_entity.noteText)+)
    >> s:pattern [
         name = "descrip_antonymConcept"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:descrip[@type='antonymConcept']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test =
               "(.=not(*[not(local-name()='hi')]))and(parent::termEntry or parent::descripGrp/parent::termEntry)"
             "Antonym concepts should occur at the entry (concept) level. The\x{a}" ~
             "								antonym-concept in this element must be expressed in basicText."
           ]
           "\x{a}" ~
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "descrip_associatedConcept"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:descrip[@type='associatedConcept']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test =
               "(.=not(*[not(local-name()='hi')]))and (parent::termEntry or parent::langSet or parent::descripGrp/parent::termEntry or parent::descripGrp/parent::langSet)"
             "Associated concepts should occur at the termEntry or the langSet\x{a}" ~
             "								level. The term in this element must be expressed in\x{a}" ~
             "							basicText."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "descrip_audio"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:descrip[@type='audio']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test =
               "(.=not(*))and (parent::termEntry or parent::langSet or parent::tig or parent::ntig or parent::descripGrp/parent::termEntry or parent::descripGrp/parent::langSet or parent::descripGrp/parent::tig or parent::descripGrp/parent::ntig)"
             "The content of this element must be plain text. It can occur at the concept (termEntry) level, the langSet level or the term (tig or ntig) level."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "descrip_broaderConceptGeneric"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:descrip[@type='broaderConceptGeneric']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test =
               "(.=not(*[not(local-name()='hi')])) and (parent::termEntry or parent::langSet or parent::descripGrp/parent::termEntry or parent::descripGrp/parent::langSet)"
             "Generic broader concepts should occur at the termEntry level or the\x{a}" ~
             "								langSet level. The term in this element must be expressed in\x{a}" ~
             "								basicText."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "descrip_broaderConceptPartitive"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:descrip[@type='broaderConceptPartitive']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test =
               "(.=not(*[not(local-name()='hi')])) and (parent::termEntry or parent::langSet or parent::descripGrp/parent::termEntry or parent::descripGrp/parent::langSet)"
             "Partitive broader concepts should occur at the termEntry level or\x{a}" ~
             "								the langSet level. The term in this element must be expressed in\x{a}" ~
             "								basicText."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "descrip_characteristic"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:descrip[@type='characteristic']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test =
               "(.=not(*))and (parent::tig or parent::ntig or parent::descripGrp/parent::tig or parent::descripGrp/parent::ntig)"
             "A\x{a}" ~
             "								characteristic should only occur at the term (tig or ntig) level.\x{a}" ~
             "								The content of this element must be plain text."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "descrip_classificationCode"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:descrip[@type='classificationCode']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test =
               "(.=not(*)) and (parent::termEntry or parent::langSet or parent::tig or parent::ntig or parent::descripGrp/parent::termEntry or parent::descripGrp/parent::langSet or parent::descripGrp/parent::tig or parent::descripGrp/parent::ntig)"
             " The content of this element must be plainText."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "descrip_conceptPosition"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:descrip[@type='conceptPosition']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test =
               "(.=not(*)) and (parent::termEntry or parent::langSet or parent::descripGrp/parent::termEntry or parent::descripGrp/parent::langSet)"
             " Information about a concept position should occur at the termEntry\x{a}" ~
             "								level or the langSet level, and it must be expressed in\x{a}" ~
             "							plainText."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "descrip_coordinateConceptGeneric"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:descrip[@type='coordinateConceptGeneric']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test =
               "(.=not(*[not(local-name()='hi')])) and (parent::termEntry or parent::langSet or parent::descripGrp/parent::termEntry or parent::descripGrp/parent::langSet)"
             "Generic coordinate concepts should occur at the termEntry level or\x{a}" ~
             "								the langSet level. The term in this element must be expressed in\x{a}" ~
             "								basicText."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "descrip_coordinateConceptPartitive"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:descrip[@type='coordinateConceptPartitive']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test =
               "(.=not(*[not(local-name()='hi')])) and (parent::termEntry or parent::langSet or parent::descripGrp/parent::termEntry or parent::descripGrp/parent::langSet)"
             "Partitive coordinate concepts should occur at the termEntry level\x{a}" ~
             "								or the langSet level. The term in this element must be expressed in\x{a}" ~
             "								basicText."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "descrip_context"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:descrip[@type='context']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test =
               "parent::tig or parent::ntig or parent::descripGrp/parent::tig or parent::descripGrp/parent::ntig"
             "A\x{a}" ~
             "								context sentence can only occur at the term (tig)\x{a}" ~
             "							level."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "descrip_definition"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:descrip[@type='definition']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test =
               "parent::termEntry or parent::langSet or parent::tig or parent::ntig or parent::descripGrp/parent::termEntry or parent::descripGrp/parent::langSet or parent::descripGrp/parent::tig or parent::descripGrp/parent::ntig"
             " A definition must occur at the termEntry level, the langSet level,\x{a}" ~
             "								or the term (tig) level."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "descrip_example"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:descrip[@type='example']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test =
               "parent::termEntry or parent::langSet or parent::tig or parent::ntig or parent::descripGrp/parent::termEntry or parent::descripGrp/parent::langSet or parent::descripGrp/parent::tig or parent::descripGrp/parent::ntig"
             " An example must occur at the termEntry level, the langSet level,\x{a}" ~
             "								or the term (tig) level."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "descrip_explanation"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:descrip[@type='explanation']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test =
               "parent::termEntry or parent::langSet or parent::tig or parent::ntig or parent::descripGrp/parent::termEntry or parent::descripGrp/parent::langSet or parent::descripGrp/parent::tig or parent::descripGrp/parent::ntig"
             " An explanation must occur at the termEntry level, the langSet\x{a}" ~
             "								level, or the term (tig) level."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "descrip_figure"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:descrip[@type='figure']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test =
               "(.=not(*)) and (parent::termEntry or parent::langSet or parent::tig or parent::ntig or parent::descripGrp/parent::termEntry or parent::descripGrp/parent::langSet or parent::descripGrp/parent::tig or parent::descripGrp/parent::ntig)"
             " The content of this element must be plain\x{a}" ~
             "								text."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "descrip_otherBinaryData"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:descrip[@type='otherBinaryData']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test =
               "(.=not(*)) and (parent::termEntry or parent::langSet or parent::tig or parent::ntig or parent::descripGrp/parent::termEntry or parent::descripGrp/parent::langSet or parent::descripGrp/parent::tig or parent::descripGrp/parent::ntig)"
             "The content of this element must be plain\x{a}" ~
             "								text."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "descrip_quantity"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:descrip[@type='quantity']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test =
               "(.=not(*)) and (parent::tig or parent::ntig or parent::descripGrp/parent::tig or parent::descripGrp/parent::ntig)"
             "A quantity should occur at the term (tig or\x{a}" ~
             "								ntig) level. The content of this element must be plain\x{a}" ~
             "							text."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "descrip_range"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:descrip[@type='range']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test =
               "(.=not(*)) and (parent::tig or parent::ntig or parent::descripGrp/parent::tig or parent::descripGrp/parent::ntig)"
             "A range should occur at the term (tig or ntig)\x{a}" ~
             "								level. The content of this element must be plainText."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "descrip_relatedConcept"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:descrip[@type='relatedConcept']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test =
               "(.=not(*[not(local-name()='hi')])) and (parent::langSet or parent::termEntry or parent::descripGrp/parent::langSet or parent::descripGrp/parent::termEntry)"
             "Related concepts\x{a}" ~
             "								should occur at the termEntry level or the langSet level. The\x{a}" ~
             "								content of this element must be expressed in basicText."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "descrip_relatedConceptBroader"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:descrip[@type='relatedConceptBroader']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test =
               "(.=not(*[not(local-name()='hi')]) )and (parent::langSet or parent::termEntry or parent::descripGrp/parent::langSet or parent::descripGrp/parent::termEntry)"
             "Broader related\x{a}" ~
             "								concepts should occur at the termEntry level or the langSet level.\x{a}" ~
             "								The content of this element must be expressed in\x{a}" ~
             "							basicText."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "descrip_relatedConceptNarrower"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:descrip[@type='relatedConceptNarrower']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test =
               "(.=not(*[not(local-name()='hi')])) and (parent::langSet or parent::termEntry or parent::descripGrp/parent::langSet or parent::descripGrp/parent::termEntry)"
             "Narrower related\x{a}" ~
             "								concepts should occur at the termEntry level or the langSet level.\x{a}" ~
             "								The content of this element must be expressed in\x{a}" ~
             "							basicText."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "descrip_reliabilityCode"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:descrip[@type='reliabilityCode']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test =
               "((.='1' or .='2' or .='3' or .='4' or .='5' or .='6' or .='7' or .='8' or .='9' or .='10') and (parent::langSet or parent::termEntry or parent::tig or parent::ntig or parent::descripGrp/parent::langSet or parent::descripGrp/parent::termEntry or parent::descripGrp/parent::tig or parent::descripGrp/parent::ntig))"
             "A reliability code can be a value from 1 (least reliable) to 10\x{a}" ~
             "								(most reliable)."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "descrip_sampleSentence"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:descrip[@type='sampleSentence']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test =
               "parent::tig or parent::ntig or parent::descripGrp/parent::tig or parent::descripGrp/parent::ntig"
             " A sample sentence can only occur at the\x{a}" ~
             "								term (tig) level."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "descrip_sequentiallyRelatedConcept"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:descrip[@type='sequentiallyRelatedConcept']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test =
               "(.=not(*[not(local-name()='hi')])) and (parent::langSet or parent::termEntry or parent::descripGrp/parent::langSet or parent::descripGrp/parent::termEntry)"
             "Sequentially related\x{a}" ~
             "								concepts should occur at the termEntry level or the langSet level.\x{a}" ~
             "								The content of this element must be expressed in\x{a}" ~
             "							basicText."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "descrip_spatiallyRelatedConcept"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:descrip[@type='spatiallyRelatedConcept']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test =
               "(.=not(*[not(local-name()='hi')])) and (parent::langSet or parent::termEntry or parent::descripGrp/parent::langSet or parent::descripGrp/parent::termEntry)"
             "Spatially related\x{a}" ~
             "								concepts should occur at the termEntry level or the langSet level.\x{a}" ~
             "								The content of the element must be expressed in\x{a}" ~
             "							basicText."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "descrip_subjectField"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:descrip[@type='subjectField']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test =
               "(.=not(*)) and (parent::termEntry or parent::descripGrp/parent::termEntry)"
             " A subject field must be a plainText value.\x{a}" ~
             "								Subject fields usually occur at the termEntry level."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "descrip_subordinateConceptGeneric"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:descrip[@type='subordinateConceptGeneric']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test =
               "(.=not(*[not(local-name()='hi')])) and (parent::langSet or parent::termEntry or parent::descripGrp/parent::langSet or parent::descripGrp/parent::termEntry)"
             " Generic subordinate\x{a}" ~
             "								concepts should occur at the termEntry level or the langSet level.\x{a}" ~
             "								The content of the element must be expressed in\x{a}" ~
             "							basicText."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "descrip_subordinateConceptPartitive"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:descrip[@type='subordinateConceptPartitive']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test =
               "(.=not(*[not(local-name()='hi')])) and (parent::langSet or parent::termEntry or parent::descripGrp/parent::langSet or parent::descripGrp/parent::termEntry)"
             " Partitive\x{a}" ~
             "								subordinate concepts should occur at the termEntry level or the\x{a}" ~
             "								langSet level. The content of the element must be expressed in\x{a}" ~
             "								basicText."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "descrip_superordinateConceptGeneric"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:descrip[@type='superordinateConceptGeneric']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test =
               "(.=not(*[not(local-name()='hi')])) and (parent::langSet or parent::termEntry or parent::descripGrp/parent::langSet or parent::descripGrp/parent::termEntry)"
             "Generic\x{a}" ~
             "								superordinate concepts should occur at the termEntry level or the\x{a}" ~
             "								langSet level. The content of the element must be expressed in\x{a}" ~
             "								basicText."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "descrip_superordinateConceptPartitive"
         "\x{a}" ~
         "						                        "
         s:rule [
           context =
             "tei:descrip[@type='superordinateConceptPartitive']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test =
               "(.=not(*[not(local-name()='hi')])) and (parent::langSet or parent::termEntry or parent::descripGrp/parent::langSet or parent::descripGrp/parent::termEntry)"
             "Partitive\x{a}" ~
             "								superordinate concepts should occur at the termEntry level or the\x{a}" ~
             "								langSet level. The content of the element must be expressed in\x{a}" ~
             "								basicText."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "descrip_table"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:descrip[@type='table']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test =
               "(.=not(*)) and (parent::langSet or parent::termEntry or parent::tig or parent::ntig or parent::descripGrp/parent::langSet or parent::descripGrp/parent::termEntry or parent::descripGrp/parent::tig or parent::descripGrp/parent::ntig)"
             " The content of this element must be plain\x{a}" ~
             "								text."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "descrip_temporallyRelatedConcept"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:descrip[@type='temporallyRelatedConcept']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test =
               "(.=not(*[not(local-name()='hi')])) and (parent::langSet or parent::termEntry or parent::descripGrp/parent::langSet or parent::descripGrp/parent::termEntry)"
             "Temporally related\x{a}" ~
             "								concepts should occur at the termEntry level or the langSet level.\x{a}" ~
             "								The content of the element must be expressed in\x{a}" ~
             "							basicText."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "descrip_thesaurusDescriptor"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:descrip[@type='thesaurusDescriptor']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test =
               "(.=not(*)) and (parent::termEntry or parent::descripGrp/parent::termEntry)"
             "Thesaurus descriptors should occur at the\x{a}" ~
             "								termEntry level. The content of this element must be plain\x{a}" ~
             "							text."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "descrip_unit"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:descrip[@type='unit']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test =
               "(not (*) and (parent::tig or parent::ntig or parent::descripGrp/parent::tig or parent::descripGrp/parent::ntig))"
             " Units should occur at the term (tig or ntig)\x{a}" ~
             "								level. Units must be expressed in plainText."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "descrip_video"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:descrip[@type='video']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test =
               "(.=not(*)) and (parent::langSet or parent::termEntry or parent::tig or parent::ntig or parent::descripGrp/parent::langSet or parent::descripGrp/parent::termEntry or parent::descripGrp/parent::tig or parent::descripGrp/parent::ntig)"
             "The content of this element must be in plain\x{a}" ~
             "								text."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ],
    IDLangTgtDtyp.attributes,
    
    ## Indicates the data-category type of the descrip element, such
    ##							as definition or associated-concept.
    attribute type {
      
      ##  (antonymConcept) A concept that is opposite in meaning to the concept
      ##									represented by the entry containing the descrip
      ##									element. A descrip element that has a type
      ##									attribute value of antonymConcept can also have a
      ##										target attribute pointing to the entry ID of the
      ##										termEntry that contains the antonym concept. The
      ##									display term in the content of the element shall be expressed in
      ##									basicText.
      "antonymConcept"
      | 
        ##  (associatedConcept) A concept that exhibits a relation to the subject concept that
        ##									can be established on the basis of non-hierarchical thematic
        ##									connections. A descrip element that has a
        ##									type attribute value of associatedConcept
        ##									can also have a target attribute pointing to the
        ##									entry ID of the termEntry that contains the associated
        ##									concept. For example, teacher and school
        ##									represent associated concepts.
        "associatedConcept"
      | 
        ##  (audio) A name or other identifier of an audio file: sound, spoken
        ##									words, music, or other audible representations used to
        ##									illustrate or explain terms or concepts. A descrip
        ##									element that has a type attribute value of
        ##									audio can also have a target attribute
        ##									pointing to the ID of a refObject in the back matter of
        ##									the TBX document instance that describes and points to the audio
        ##									file. The element content shall be in plainText. If a
        ##										direct pointer to the audio file is preferred within the
        ##											termEntry, rather than pointing to the back
        ##										matter, use an xref instead.
        ##                                  
        "audio"
      | 
        ##  (broaderConceptGeneric) A concept two or more levels of abstraction higher than
        ##									subject concept in a generic hierarchical concept system. A
        ##										descrip element that has a type
        ##									attribute value of broaderConceptGeneric can also
        ##									have a target attribute pointing to the entry ID of
        ##									the termEntry that contains the broader concept.
        ##									Generic relations between concepts are "is-a" relations. This
        ##									means that the narrower concept "is an" instance of its broader
        ##									generic concept. For example, a dog is a
        ##										canine animal, and a canine animal
        ##									is a mammal, therefore mammal is a
        ##									broader generic concept for dog.
        "broaderConceptGeneric"
      | 
        ##  (boaderConceptPartitive) A concept two or more levels of abstraction higher than
        ##									subject concept in a part-whole or meronymic hierarchical
        ##									concept system. A descrip element that has a
        ##									type attribute value of
        ##									broaderConceptPartitive can also have a
        ##									target attribute pointing to the entry ID of the
        ##										termEntry that contains the broader concept. For
        ##									example, a floor board is part of a
        ##									house (broader partitive concept), but it can be
        ##									more narrowly defined as being part of the floor
        ##									(superordinate partitive concept), which in turn is part of the
        ##									house. Partitive relations between concepts are "has-a"
        ##									relations. This means that the broader partitive concept "has"
        ##									its narrower concepts as parts of itself.
        "broaderConceptPartitive"
      | 
        ##  (characteristic) An abstraction of a property of an object or of a set of
        ##									objects. For example, flammability is a
        ##									characteristic of fuel. Essential characteristics
        ##									can be used to define concepts. The element content shall be in
        ##									plainText.
        "characteristic"
      | 
        ##  (classificationCode) A set of symbols, with rules for their application, used to
        ##									represent classes and their interrelations. A descrip
        ##									element that has a type attribute value of
        ##										classificationCode can also have a
        ##									target attribute pointing to the ID of a
        ##									bibliographic refobject in the back matter describing
        ##									the classification code. The element content shall be in plain
        ##									text. If a direct pointer to the classification code is
        ##										preferred within the termEntry, rather than
        ##										pointing to the back matter, use an xref
        ##									instead.
        ##                                  
        "classificationCode"
      | 
        ##  (conceptPosition) The position of a concept in a concept system. A
        ##									descrip element that has a type attribute
        ##									value of conceptPosition can also have a
        ##									target attribute pointing to the ID of a position in
        ##									the concept system. The element content shall be in plainText.
        "conceptPosition"
      | 
        ##  (context) A text which illustrates a concept or a term, by containing
        ##									the concept designation itself. Contexts must be authentic, that is, they must be obtained
        ##									from an existing source, and not created by the terminologist.
        ##									Contexts are documented very frequently in terminology
        ##									collections. Contexts can provide information for determining
        ##									term usage and collocations. In TBX, the context is a
        ##									term-related data-category. A context can be further categorized
        ##									according to context type.
        "context"
      | 
        ##  (coordinateConceptGeneric) A concept having the same nearest superordinate concept
        ##									 as the concept being
        ##									described by this descrip element in a generic concept
        ##									system. A descrip element that has a type
        ##									attribute value of coordinateConceptGeneric can also
        ##									have a target attribute pointing to the ID of the
        ##									coordinate concept.
        "coordinateConceptGeneric"
      | 
        ##  (coordinateConceptPartitive) A concept having the same nearest superordinate concept
        ##									 as the concept being
        ##									described by this descrip element in a partitive
        ##									concept system. A descrip element that has a
        ##									type attribute value of
        ##										coordinateConceptPartitive can also have a
        ##										target attribute pointing to the ID of the
        ##									coordinate concept.
        "coordinateConceptPartitive"
      | 
        ##  (definition) A representation of a concept by a descriptive statement which
        ##									serves to differentiate that concept from related
        ##								concepts.
        "definition"
      | 
        ##  (example) A text which illustrates a concept or a term, by providing an
        ##									example of the object designated by the concept or term, and not
        ##									necessarily containing the concept designation itself.
        ##									
        "example"
      | 
        ##  (explanation) A statement that describes and clarifies a concept and makes
        ##									it understandable, but does not necessarily differentiate it
        ##									from other concepts.Some databases use example as a
        ##									label for contextual references. The content of those
        ##									data-categories should be converted to the data-category  for interchange purposes.
        "explanation"
      | 
        ##  (figure) A name or other description of a diagram, picture, or other
        ##									graphic material used to illustrate a concept or group of
        ##									concepts. A descrip element that has a type
        ##									attribute value of figure can also have a
        ##									target attribute pointing to the ID of a
        ##										refObject in the back matter of the TBX document
        ##									instance that describes and points to the file that contains the
        ##									figure. The element content shall be in plainText. If a
        ##										direct pointer to the file that contains the figure is
        ##										preferred within the termEntry, rather than
        ##										pointing to the back matter, use an xref
        ##									instead.
        ##                                  
        "figure"
      | 
        ##  (otherBinaryData) Any binary data not covered by the categories , , , and . A
        ##									descrip element that has a type attribute
        ##									value of otherBinaryData can also have a
        ##									target attribute pointing to the ID of a
        ##										refObject in the back matter of the TBX document
        ##									instance that describes and points to the binary file. The
        ##									element content shall be in plainText. If a direct pointer
        ##										to the binary file is preferred within the
        ##										termEntry, rather than pointing to the back matter,
        ##										use an xref instead.
        ##                                  
        "otherBinaryData"
      | 
        ##  (quantity) A measurable quantity associated with a concept. The element
        ##									content shall be in plainText.
        "quantity"
      | 
        ##  (range) The pair of limits within which a quantity is measured, as
        ##									expressed by stating the lower and upper permissible values.
        ##									The
        ##									element content shall be in plainText.
        "range"
      | 
        ##  (relatedConcept) A concept that has an associative relation to another concept,
        ##									such as teacher and school. A
        ##										descrip element that has a type
        ##									attribute value of relatedConcept can also have a
        ##										target attribute pointing to the entry identifier
        ##									of the related concept.
        "relatedConcept"
      | 
        ##  (relatedConceptBroader) A concept that is broader at some level with respect to a
        ##									related or associated concept, but without comprising any
        ##									reference to a generic or partitive system. A descrip
        ##									element that has a type attribute value of
        ##										relatedConceptBroader can also have a
        ##									target attribute pointing to the entry identifier of
        ##									the related concept.
        "relatedConceptBroader"
      | 
        ##  (relatedConceptNarrower) A concept that is narrower at some level with respect to a
        ##									related or associated concept, but without comprising any
        ##									reference to a generic or partitive system. A descrip
        ##									element that has a type attribute value of
        ##										relatedConceptNarrower can also have a
        ##										target attribute pointing to the entry identifier
        ##									of the related concept.
        "relatedConceptNarrower"
      | 
        ##  (reliabilityCode) A code assigned to a data-category or record indicating
        ##									accuracy and/or completeness. The content of the
        ##									descrip element when it has a type attribute
        ##									value of reliabilityCode shall be a value from 1
        ##									(least reliable) to 10 (most reliable).
        "reliabilityCode"
      | 
        ##  (sampleSentence) A sentence composed (frequently by a terminologist or language
        ##									planner) to illustrate the use of a term in cases where an
        ##									authentic context is unavailable. Although contextual
        ##									information should ideally be taken from actual texts written in
        ##									the language in question, such contextual references may not
        ##									exist for newly coined or suggested terms.
        "sampleSentence"
      | 
        ##  (sequentiallyRelatedConcept) A concept that has a relation to the subject concept based on
        ##									spatial or temporal proximity. Temporal relations and spatial
        ##									relations can be sequential. A descrip element that has
        ##									a type attribute value of
        ##										sequentiallyRelatedConcept can also have a
        ##										target attribute pointing to the entry identifier
        ##									of the related concept.
        "sequentiallyRelatedConcept"
      | 
        ##  (spatiallyRelatedConcept) A concept that has a relation of dependence with the subject
        ##									concept, referring to objects based on their relative physical
        ##									positions. A descrip element that has a type
        ##									attribute value of spatiallyRelatedConcept can also
        ##									have a target attribute pointing to the entry
        ##									identifier of the related concept.
        "spatiallyRelatedConcept"
      | 
        ##  (subjectField) A field of special knowledge.
        ##									
        ##									Subject fields can be expressed in multiple levels, for example:
        ##									Subject field (level 1): disease, Subject field (level 2):
        ##									cancer, Subject field (level 3): non-Hodgkin's lymphoma. Subject
        ##									fields shall be expressed in plainText, and preferably be
        ##									selected from a defined set of picklist values. Subject fields
        ##									shall be specified at the concept (termEntry) level.
        "subjectField"
      | 
        ##  (subordinateConceptGeneric) A concept that has a generic relation with the subject
        ##									concept, and a broader intension. A descrip element
        ##									that has a type attribute value of
        ##										subordinateConceptGeneric can also have a
        ##										target attribute pointing to the entry identifier
        ##									of the subordinate concept.
        "subordinateConceptGeneric"
      | 
        ##  (subordinateConceptPartitive) A concept that has a partitive relation with the subject
        ##									concept, and represents one of the parts of the subject concept.
        ##									A descrip element that has a type attribute
        ##									value of subordinateConceptPartitive can also have a
        ##										target attribute pointing to the entry identifier
        ##									of the subordinate concept.
        "subordinateConceptPartitive"
      | 
        ##  (superordinateConceptGeneric) A concept that has a generic relation with the subject
        ##									concept, and a narrower intension. A descrip element
        ##									that has a type attribute value of
        ##										superordinateConceptGeneric can also have a
        ##										target attribute pointing to the entry identifier
        ##									of the superordinate concept.
        "superordinateConceptGeneric"
      | 
        ##  (superordinateConceptPartitive) A concept that has a partitive relation with the subject
        ##									concept, and represents the sum of the parts; a
        ##										comprehensive concept. A descrip
        ##									element that has a type attribute value of
        ##										superordinateConceptPartitive can also have a
        ##										target attribute pointing to the entry identifier
        ##									of the superordinate concept.
        "superordinateConceptPartitive"
      | 
        ##  (table) The name of a table that is used to describe a concept. The
        ##									table itself can be contained (or referred to as an external
        ##									file) in a refobject in the back matter of a TBX
        ##									document instance. The target attribute points to the
        ##										refobject identifier. The element content shall be
        ##									in plainText. If a direct pointer to the file that
        ##										contains the table is preferred within the
        ##										termEntry, rather than pointing to the back matter,
        ##										use an xref instead.
        ##								                         
        "table"
      | 
        ##  (temporallyRelatedConcept) A concept related to the subject concept through a sequential
        ##									relation involving events in time. A descrip element
        ##									that has a type attribute value of
        ##										temporallyRelatedConcept can also have a
        ##										target attribute pointing to the entry identifier
        ##									of the related concept.
        "temporallyRelatedConcept"
      | 
        ##  (thesaurusDescriptor) The term in a thesaurus that can be used to represent a
        ##									concept in a terminological entry. A descrip element
        ##									that has a type attribute value of
        ##										thesaurusDescriptor can also have a
        ##									target attribute pointing to the ID of the
        ##										refObject in the back matter of the TBX document
        ##									instance that describes the thesaurus. The element content shall
        ##									be in plainText. If a direct pointer to the thesaurus is
        ##										preferred within the termEntry, rather than
        ##										pointing to the back matter, use an xref
        ##									instead.
        ##								                         
        "thesaurusDescriptor"
      | 
        ##  (unit) A precisely-specified quantity in terms of which the
        ##									magnitudes of other quantities can be stated, such as meter or
        ##									volt. The element content shall be in plainText.
        ##									
        "unit"
      | 
        ##  (video) A name or other description of recorded visual images used to
        ##									represent or illustrate terminological information. A
        ##										descrip element that has a type
        ##									attribute value of video can also have a
        ##									target attribute pointing to the ID of a
        ##										refObject in the back matter of the TBX document
        ##									instance that describes and points to the video file. The
        ##									element content shall be in plainText. If a direct pointer
        ##										to the video file is preferred within the
        ##										termEntry, rather than pointing to the back matter,
        ##										use an xref instead.
        ##                                  
        "video"
    },
    empty
  }
tbx_descripGrp =
  
  ## Contains one descrip element as well as additional child elements for
  ##					associated administrative information.
  element descripGrp {
    tbx_descrip,
    (tbx_descripNote | tbx_admin | tbx_note | tbx_ref)*,
    id.attributes,
    empty
  }
tbx_descripNote =
  
  ## Element used to indicate the type of definition or context with which it is
  ##					associated.
  element descripNote {
    text
    >> s:pattern [
         name = "descripNote_contextType"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:descripNote[@type='contextType']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test =
               ". ='definingContext'  or .='explanatoryContext'  or .='associativeContext'  or .='linguisticContext'  or .='metalinguisticContext'  or .='translatedContext'"
             " Contexts can only be of one of the following types:\x{a}" ~
             "								definingContext, explanatoryContext, associativeContext,\x{a}" ~
             "								linguisticContext, metalinguisticContext or\x{a}" ~
             "							translatedContext."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "descripNote_definitionType"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:descripNote[@type='definitionType']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test =
               ".=         'intensionalDefinition' or .='extensionalDefinition' or .='partitiveDefinition' or .='translatedDefinition'"
             " Definitions can only be of one of the following types:\x{a}" ~
             "								intensionalDefinition, extensionalDefinition, partitiveDefinition,\x{a}" ~
             "								or translatedDefinition."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ],
    IDLangTgtDtyp.attributes,
    
    ## Indicates the data-category type of the descripNote element,
    ##							such as contextType.
    attribute type {
      
      ##  (contextType) The characterization of a context according to a set of
      ##									theoretical or pragmatic types.The content of the descripNote element when it has a
      ##										type attribute value of contextType
      ##									shall be one of the following:
      ##										                              * definingContext
      ##										                              * explanatoryContext
      ##										                              * associativeContext
      ##										                              * linguisticContext
      ##										                              * metalinguisticContext
      ##										                              * translatedContext
      ##									                           
      ##                                  
      "contextType"
      | 
        ##  (definitionType) The characterization of a definition according to a set of
        ##									theoretical or pragmatic types.The content of the descripNote element when it has a
        ##										type attribute value of definitionType
        ##									shall be one of the following:
        ##										                              * intensionalDefinition
        ##										                              * extensionalDefinition
        ##										                              * partitiveDefinition
        ##										                              * translatedDefinition
        ## 
        ##									                           
        ##                                  
        "definitionType"
    },
    empty
  }
tbx_hi =
  
  ##  Highlights a segment of text and optionally points to another element.
  element hi {
    text,
    target-IDREF.attributes,
    lang.attributes,
    
    ##
    attribute type {
      
      ##  (entailedTerm) A term, found in the content of a text element such as
      ##										, that is defined in
      ##									another terminological entry in the same terminological
      ##									collection.
      "entailedTerm"
      | 
        ##  (hotkey) A key or a combination of keys on a computer keyboard that,
        ##									when pressed at one time, performs a task (such as starting an
        ##									application) as an alternative to using a mouse or other input
        ##									device. Hotkeys are supported by many operating systems and
        ##									applications (the hotkey is indicated by an ampersand in the
        ##									term and by an underscore in the visual display). This type of
        ##										hi element allows a hotkey to be identified as such
        ##									in a text field such as a context sentence. To identify a hotkey
        ##									for the head term of an entry, use the lionHotkey
        ##									value of the type attribute on a
        ##								termNote.
        "hotkey"
      | 
        ##  (italics) Indicates that the content enclosed in the hi element
        ##									must be rendered in italics. 
        "italics"
      | 
        ##  (bold) Indicates that the content enclosed in the hi element
        ##									must be rendered in boldface. 
        "bold"
      | 
        ##  (superscript) Indicates that the content enclosed in the hi element
        ##									must be rendered in superscript. 
        "superscript"
      | 
        ##  (subscript) Indicates that the content enclosed in the hi element
        ##									must be rendered in subscript.
        "subscript"
      | 
        ##  (math) Indicates that the content enclosed in the hi element
        ##									is mathematical in nature.
        "math"
    }?,
    empty
  }
tbx_langSet =
  
  ## A nesting element that contains all the information in a terminological entry
  ##					pertaining to one language, including all the tig or
  ##					ntigelements (terms and associated information) for that language.
  element langSet {
    tbx_entity.auxInfo,
    (tbx_ntig)+,
    
    ## Indicates the language of the language section. This attribute is
    ##							required for the langSet element. See also the description on
    ##							the martif element.
    attribute xml:lang { text },
    empty
  }
tbx_note =
  
  ## Any kind of note. 
  element note { tbx_entity.noteText, idlang.attributes, empty }
tbx_ntig =
  
  ## A nesting term information group. A grouping element that
  ##					contains child elements describing a term. It is equivalent to a tig
  ##					except that it allows the description of term components.
  element ntig { tbx_termGrp, tbx_entity.auxInfo, id.attributes, empty }
tbx_term =
  
  ## The term that is being described in a tig or ntig. This
  ##					element, as well as other term-like elements such as those mentioned in the
  ##					table Types of terms, relations to terms in section 9, can contain
  ##					a hi element to allow a limited amount of inline markup. This is
  ##					intended to handle markup requirements in special cases such as may be required
  ##					for terms that represent scientific concepts. However, it is strongly
  ##					recommended to use inline markup only when necessary to represent the term in
  ##					its base form. Do not use the hi element for presentational styles
  ##					chosen for esthetic purposes.
  element term { tbx_entity.basicText, id.attributes, empty }
tbx_ref =
  
  ## A cross-reference that points to another element within the martif
  ##					element of the TBX document instance. The content of the element is display text
  ##					of the target element (i.e. the term), and shall be in plainText.
  element ref {
    text,
    IDLangTgtDtyp.attributes,
    
    ##
    attribute type {
      
      ##  (crossReference) A pointer to another related location, such as another entry
      ##									or another term. The ref element with a type
      ##									attribute value of cross-reference shall also have a
      ##										target attribute to point to the identifier of
      ##									the entry or term.
      "crossReference"
      | 
        ##  (see) An element that points to a location where additional
        ##									information can be found. The ref element with a
        ##										type attribute value of see shall also
        ##									have a target attribute to point to the location of
        ##									the information.
        "see"
    },
    empty
  }
tbx_termComp =
  
  ## A term component. It includes the text of a part of a word (such as a morpheme
  ##					or a syllable) or one of the words making up a multi-word term. The type of term
  ##					component will depend on the value of the type attribute of the
  ##						termCompList element.
  element termComp { text, idlang.attributes, empty }
tbx_termCompGrp =
  
  ## A grouping element that includes one termComp plus additional
  ##					elements describing the term component, such as notes, administrative
  ##					information, and cross references.
  element termCompGrp {
    tbx_termComp, (tbx_termNote)*, id.attributes, empty
  }
tbx_termCompList =
  
  ## A grouping element that contains at least one termComp element
  ##					(usually more) or at least one termCompGrp element plus optionally some
  ##					additional information about the term components. This element is designed to
  ##					contain the components of a term. The value of the type attribute
  ##					indicates what type of term components it contains.
  element termCompList {
    tbx_entity.auxInfo,
    (tbx_termComp | tbx_termCompGrp)+,
    id.attributes,
    
    ## Indicates the type of the termCompList, such as
    ##								hyphenation. The value indicates on what basis the term
    ##							components were identified, such as by hyphenation parts or by
    ##							syllables.
    attribute type {
      
      ##  (Hyphenation) The termComp elements contain the parts of a term as
      ##									it would be hyphenated, such as at the end of a line, according
      ##									to a given set of rules.
      "hyphenation"
      | 
        ##  (Lemma) The termComp elements contain the base form of the
        ##									term or of the individual words that it comprises. A base form
        ##									of a word or term, sometimes called a lemma, is the
        ##									form that is used as the formal dictionary entry for the term.
        ##									For nouns, the base form is frequently the nominative singular
        ##									form (in languages that show variation by case). For adjectives
        ##									it is the positive form of the adjective, as opposed to the
        ##									comparative, and in some languages it is uninflected, whereas in
        ##									others it is the masculine singular. For verbs, it is generally
        ##									the infinitive.
        "lemma"
      | 
        ##  (Morphological element) The termComp elements contain the individual
        ##									morphemes that comprise the term. .
        "morphologicalElement"
      | 
        ##  (Syllabification) The termComp elements contain the individual
        ##									syllables that comprise the term.
        "syllabification"
      | 
        ##  (Term element) The termComp elements contain any other logically
        ##									significant portion of the term. 
        "termElement"
    },
    empty
  }
tbx_termEntry =
  
  ## The root element of a terminological entry. It shall contain at least one
  ##					language section.
  element termEntry {
    tbx_entity.auxInfo, tbx_langSet+, id.attributes, empty
  }
tbx_termGrp =
  
  ## Element used in an ntig which contains one term and
  ##					optionally additional information about the term. This element is primarily used
  ##					in conjunction with ntig when the term is broken down into components. 
  element termGrp {
    tbx_term, (tbx_termNote)*, tbx_termCompList*, id.attributes, empty
  }
tbx_termNote =
  
  ## A meta data-category used for describing terms. A type attribute
  ##					specifies what kind of information is included in a particular instance of this
  ##					element.
  element termNote {
    tbx_entity.noteText
    >> s:pattern [
         name = "termNote_abbreviatedFormFor"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:termNote[@type='abbreviatedFormFor']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test = ".=not(*[not(local-name()='hi')])"
             " The value of the\x{a}" ~
             "								abbreviated form in this element must be expressed in basicText.\x{a}" ~
             "							"
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "termNote_administrativeStatus"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:termNote[@type='administrativeStatus']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test =
               ".=         'standardizedTerm-admn-sts' or .='preferredTerm-admn-sts' or .='admittedTerm-admn-sts' or .='deprecatedTerm-admn-sts' or .='supersededTerm-admn-sts' or .='legalTerm-admn-sts' or .='regulatedTerm-admn-sts'"
             "The administrative status must be standardizedTerm-admn-sts,\x{a}" ~
             "								preferredTerm-admn-sts, admittedTerm-admn-sts,\x{a}" ~
             "								deprecatedTerm-admn-sts, supersededTerm-admn-sts,\x{a}" ~
             "								legalTerm-admn-sts, or regulatedTerm-admn-sts. "
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "termNote_antonymTerm"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:termNote[@type='antonymTerm']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test = "(.=not(*[not(local-name()='hi')]))"
             "Antonym terms should\x{a}" ~
             "								occur at the term (tig or ntig) level. The antonym term in this\x{a}" ~
             "								element must be expressed in basicText."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "termNote_directionality"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:termNote[@type='directionality']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test =
               ". =        'monodirectional' or .='bidirectional' or .='incommensurate'"
             "The directionality must be monodirectional, bidirectional, or\x{a}" ~
             "								incommensurate. "
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "termNote_etymology"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:termNote[@type='etymology']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test = ".=not(*)"
             "Information about the etymology of a term must\x{a}" ~
             "								be expressed in noteText. Etymology information should occur at the\x{a}" ~
             "								tig level or at the termCompGrp level."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "termNote_falseFriend"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:termNote[@type='falseFriend']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test = "(.=not(*[not(local-name()='hi')]))"
             " The false friend\x{a}" ~
             "								must be expressed in basicText. "
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "termNote_frequency"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:termNote[@type='frequency']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test =
               ". =        'commonlyUsed' or .='infrequentlyUsed' or .='rarelyUsed'"
             "The frequency must be commonlyUsed, infrequentlyUsed, or\x{a}" ~
             "								rarelyUsed. "
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "termNote_geographicalUsage"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:termNote[@type='geographicalUsage']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test = ".=not(*)"
             "The geographical usage must be expressed in\x{a}" ~
             "								plainText. "
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "termNote_grammaticalGender"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:termNote[@type='grammaticalGender']"
           "\x{a}" ~
           "\x{a}" ~
           "							                          "
           s:assert [
             test =
               "(.='masculine' or .='feminine' or .='neuter' or .='otherGender')"
             " The gender must be masculine, feminine, neuter, or otherGender.\x{a}" ~
             "								Gender should be specified at the term level (tig or ntig) or at the\x{a}" ~
             "								termCompGrp level."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "termNote_grammaticalNumber"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:termNote[@type='grammaticalNumber']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test =
               ". =         'single' or .='plural' or .='dual' or .='mass' or .='otherNumber'"
             "The grammatical number must be single, plural, dual, mass, or\x{a}" ~
             "								otherNumber. The grammatical number should be specified at the term\x{a}" ~
             "								level (tig or ntig) or at the termCompGrp level."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "termNote_grammaticalValency"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:termNote[@type='grammaticalValency']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test = ".=not(*)"
             " The grammatical valency must be expressed in\x{a}" ~
             "								plainText. "
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "termNote_homograph"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:termNote[@type='homograph']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test = ".=not(*[not(local-name()='hi')])"
             " The homograph must\x{a}" ~
             "								be expressed in basicText. "
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "termNote_language-planningQualifier"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:termNote[@type='language-planningQualifier']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test =
               ". =        'recommendedTerm' or .='nonstandardizedTerm' or .='proposedTerm' or .='newTerm'"
             "The language planning qualifier must be recommendedTerm,\x{a}" ~
             "								nonstandardizedTerm, proposedTerm, or newTerm. "
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "termNote_lionHotkey"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:termNote[@type='lionHotkey']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test = ".=not(*)"
             "The hotkey must be expressed in plainText.\x{a}" ~
             "							"
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "termNote_normativeAuthorization"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:termNote[@type='normativeAuthorization']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test =
               ". =        'standardizedTerm' or .='preferredTerm' or .='admittedTerm' or .='deprecatedTerm' or .='supersededTerm' or .='legalTerm' or .='regulatedTerm'"
             "The normative authorization must be standardizedTerm,\x{a}" ~
             "								preferredTerm, admittedTerm, deprecatedTerm, supersededTerm,\x{a}" ~
             "								legalTerm, regulatedTerm . "
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "termNote_partOfSpeech"
         "\x{a}" ~
         "						\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:termNote[@type='partOfSpeech']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test = ".=not(*)"
             "The part of speech must be a plainText value.\x{a}" ~
             "								It should be specified only at the term (tig or ntig) level or at\x{a}" ~
             "								the termCompGrp level."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "termNote_processStatus"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:termNote[@type='processStatus']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test =
               ". =        'unprocessed' or .='provisionallyProcessed' or .='finalized'"
             "The process status must be unprocessed, provisionallyProcessed, or\x{a}" ~
             "								finalized. "
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "termNote_pronunciation"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:termNote[@type='pronunciation']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test = ".=not(*[not(local-name()='hi')])"
             "The pronunciation\x{a}" ~
             "								must be expressed in basicText. It should be specified at the term\x{a}" ~
             "								(tig or ntig) level or at the termCompGrp level."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "termNote_proprietaryRestriction"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:termNote[@type='proprietaryRestriction']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test =
               ". =        'trademark' or .='serviceMark' or .='tradeName'"
             "The proprietary restriction must be trademark, serviceMark, or\x{a}" ~
             "								tradeName. "
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "termNote_register"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:termNote[@type='register']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test =
               ". =        'colloquialRegister' or .='neutralRegister' or .='technicalRegister' or .='in-houseRegister' or .='bench-levelRegister' or .='slangRegister' or .='vulgarRegister'"
             "The register must be colloquialRegister, neutralRegister,\x{a}" ~
             "								technicalRegister, in-houseRegister, bench-levelRegister,\x{a}" ~
             "								slangRegister, or vulgarRegister . "
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "termNote_shortFormFor"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:termNote[@type='shortFormFor']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test = ".=not(*[not(local-name()='hi')])"
             " The value of the\x{a}" ~
             "								short form in this element must be expressed in\x{a}" ~
             "							basicText."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "termNote_temporalQualifier"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:termNote[@type='temporalQualifier']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test =
               ". =        'archaicTerm' or .='outdatedTerm' or .='obsoleteTerm'"
             "The temporal qualifier must be archaicTerm, outdatedTerm, or\x{a}" ~
             "								obsoleteTerm. "
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "termNote_termLocation"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:termNote[@type='termLocation']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test = ".=not(*)"
             "The termLocation must be a plainText value. It\x{a}" ~
             "								should be specified only at the term (tig or ntig)\x{a}" ~
             "							level."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "termNote_termProvenance"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:termNote[@type='termProvenance']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test =
               ". =         'transdisciplinaryBorrowing' or .='translingualBorrowing' or .='loanTranslation' or .='neologism'"
             "The term provenance must be transdisciplinaryBorrowing,\x{a}" ~
             "								translingualBorrowing, loanTranslation, or neologism."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "termNote_termType"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:termNote[@type='termType']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test =
               ". = 'abbreviation' or .='initialism' or .='acronym' or .='clippedTerm' or .='entryTerm' or .='synonym' or .='internationalScientificTerm' or .='fullForm' or .='transcribedForm' or .='symbol' or .='formula' or .='equation' or .='logicalExpression' or .='commonName' or .='variant' or .='shortForm' or .='transliteratedForm' or .='sku' or .='partNumber' or .='phraseologicalUnit' or .='synonymousPhrase' or .='standardText' or .='string' or .='internationalism' or .='shortcut'"
             "The type of term can only be one of the following values:\x{a}" ~
             "								abbreviation, initialism, acronym, clippedTerm, entryTerm, synonym,\x{a}" ~
             "								internationalScientificTerm, fullForm, transcribedForm, symbol,\x{a}" ~
             "								formula, equation, logicalExpression, commonName, variant,\x{a}" ~
             "								shortForm, transliteratedForm, sku, partNumber, phraseologicalUnit,\x{a}" ~
             "								synonymousPhrase, standardText, string, internationalism,\x{a}" ~
             "							shortcut."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "termNote_termStructure"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:termNote[@type='termStructure']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test = ".=not(*)"
             " The term structure must be expressed in plain\x{a}" ~
             "								text."
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ]
    >> s:pattern [
         name = "termNote_timeRestriction"
         "\x{a}" ~
         "						                        "
         s:rule [
           context = "tei:termNote[@type='timeRestriction']"
           "\x{a}" ~
           "							                          "
           s:assert [
             test = ".=not(*)"
             " The time restriction must be expressed in\x{a}" ~
             "								plainText. "
           ]
           "\x{a}" ~
           "						                        "
         ]
         "\x{a}" ~
         "					                      "
       ],
    IDLangTgtDtyp.attributes,
    
    ## Indicates the data-category type of the termNote, such as
    ##								partOfSpeech or termType.
    attribute type {
      
      ##  (abbreviatedFormFor) A link used to identify a relation between a term that is an
      ##									abbreviated form, and its full or expanded form. It may be
      ##									coupled with a target attribute to point to the entry
      ##									of the full or expanded form. For example, the term
      ##									WWW could have the following tag to point to its
      ##									full form: World Wide
      ##									Web. The actual content of the element would
      ##									be the text World Wide Web, which allows the user
      ##									to see what term is the full form of the current term without
      ##									having to go to the location of the full form in the file (the
      ##									location would normally be somewhere within the current entry,
      ##									since the abbreviated form and the full form represent the same
      ##									concept). The element content shall be expressed in basicText.
      ##									The identification of a relation between an abbreviated term and
      ##									its full form indicates which term in a terminological entry is
      ##									the full form of the abbreviated term.
      ##									In
      ##									many languages, English abbreviations are commonly used, but the
      ##									English full form may be avoided in favor of an equivalent full
      ##									form in the language in question. In this case, the English
      ##									abbreviation and the target language full form will both appear
      ##									in the target language section of the entry.
      "abbreviatedFormFor"
      | 
        ##  (administrativeStatus) The status of a term within a certain working environment. The
        ##									data-category administrativeStatus should be linked,
        ##									through a target attribute, to a refObject
        ##									in the back matter that identifies the administrative
        ##									organization that determined the status. The element
        ##										termNote when its type attribute has the
        ##									value administrativeStatus shall contain one of the
        ##									following values:
        ##										                              * admittedTerm-admn-sts
        ##										                              * deprecatedTerm-admn-sts
        ##										                              * legalTerm-admn-sts
        ##										                              * preferredTerm-admn-sts
        ##										                              * regulatedTerm-admn-sts
        ##										                              * standardizedTerm-admn-sts
        ##										                              * supersededTerm-admn-sts
        ##									                           
        ##									                           The status of terms with respect to a standardization
        ##										process is covered by normativeAuthorization.
        ##									
        ##                                  
        "administrativeStatus"
      | 
        ##  (animacy) The characteristic of a word indicating that in a given
        ##									discourse community, its referent is considered to be alive or
        ##									to possess a quality of volition or consciousness. The value of
        ##									the termNote element when it has a type
        ##									attribute value of animacy shall be one of:
        ##										animate, inanimate,
        ##									otherAnimacy.
        "animacy"
      | 
        ##  (antonymTerm) A term that designates a concept that is opposite in meaning
        ##									to the concept being described in the current entry. A
        ##										termNote element that has a type
        ##									attribute value of antonymTerm can also have a
        ##										target attribute pointing to the term ID of the
        ##									term that represents the antonym concept. The display term in
        ##									the content of this element shall be expressed in basicText.
        "antonymTerm"
      | 
        ##  (directionality) A data-category that, through the value of its target
        ##									attribute, indicates the preferred translation of the term in
        ##									the term element of the current tig from among
        ##									the available translations in the entry. The target
        ##									attribute should point to the identifier of the tig
        ##									corresponding to the target term. In the case of the values
        ##										monodirectional and bidirectional, the
        ##									target term is the preferred translation. The content of the
        ##										termNote element when it has a type
        ##									attribute value of directionality indicates the scope
        ##									of directionality, and shall be one of the following:
        ##										                              * 
        ##                                           monodirectional: The translation is only
        ##											preferred going from the source language (current
        ##												tig to the target language (target
        ##											tig).
        ## 
        ##										                              * 
        ##                                           bidirectional: The translation is preferred
        ##											in both directions, i.e. the term in the target
        ##											tig is a preferred translation of the term in
        ##											the current tig and vice-versa.
        ## 
        ##										                              * 
        ##                                           incommensurate: The relation between the
        ##											term in the current tig and the term in the
        ##											target tig as translations is imperfect and
        ##											should be used with care. In this case, the concepts are
        ##											not equal. A 
        ##											should be used to provide information about the
        ##											difference between the concepts.
        ## 
        ##										                              * 
        ##                                           undetermined: The scope of directionality
        ##											has not been determined.
        ## 
        ##									                           
        ##                                  
        "directionality"
      | 
        ##  (etymology) Information on the origin of a word and the development of its
        ##									meaning. The element content shall be expressed in noteText.
        ##								
        "etymology"
      | 
        ##  (falseFriend) A term in another language that appears to be semantically or
        ##									morphologically similar to the subject term in the entry, but
        ##									that does not represent the same concept. For example, in
        ##									French, the term réaliser means "to accomplish",
        ##									and therefore, it is a false friend of the English term
        ##										realize (i.e. to become conscious of). A
        ##										termNote element with the type attribute
        ##									value of falseFriend can also have a
        ##									target attribute whose value is a pointer to a term
        ##									in another entry. The element content shall be expressed in
        ##									basicText.
        "falseFriend"
      | 
        ##  (frequency) The relative commonness with which a term occurs. The content
        ##									of the termNote element when it has a type
        ##									attribute value of frequency shall be one of:
        ##										commonlyUsed, infrequentlyUsed,
        ##										rarelyUsed. The assessment of frequency of a term
        ##									can be based on subjective criteria, or it can reflect computer
        ##									analysis of text corpora.
        "frequency"
      | 
        ##  (geographicalUsage) A code identifying any specific geographical area where the
        ##									term is used, for instance, to differentiate between UK English
        ##									and US English. Preferred values are language codes combined
        ##									with geographical codes, from IETF RFC 4646 or its successor, as
        ##									identified in IETF BCP 47. For example: en-US for American
        ##									English. The element content shall be expressed in plainText.
        ##								
        "geographicalUsage"
      | 
        ##  (grammaticalGender) The gender of the word. The value of the termNote
        ##									element when it has a type attribute value of
        ##										grammaticalGender shall be one of:
        ##									masculine, feminine, neuter, or
        ##										otherGender.
        "grammaticalGender"
      | 
        ##  (grammaticalNumber) A property of a term that indicates the number of objects
        ##									referred to by the term. The content of the termNote
        ##									element when it has a type attribute value of
        ##										grammaticalNumber shall be one of:
        ##									singular, plural, dual,
        ##										mass, or otherNumber. For example, the
        ##									terms rice and bread are mass nouns
        ##									because there are no separate singular and plural forms.
        ##										If the singular and the plural forms of a term do not
        ##										designate the same concept, they should be recorded in
        ##										separate entries.
        ##                                  
        "grammaticalNumber"
      | 
        ##  (grammaticalValency) The range of syntactic elements either required or permitted
        ##									by a lexical unit. The valency of eat includes a
        ##									subject ("I" in "I am eating") and an object ("cheese" in "I am
        ##									eating cheese".) It can thus be said to be "bivalent". The
        ##									element content shall be expressed in plainText.
        ##									
        "grammaticalValency"
      | 
        ##  (homograph) A word that is spelled like the subject term in the entry, but
        ##									that has a different meaning, and origin. Homographs are terms
        ##									that have the same written form, but are derived from different
        ##									etymological origins, for example, a port for boats
        ##									and a port for computer peripherals. A
        ##									termNote element having a type attribute
        ##									value of homograph can also have a target
        ##									attribute to point to the tig of the entry that
        ##									describes the homograph. The element content shall be expressed
        ##									in basicText.
        "homograph"
      | 
        ##  (language-planningQualifier) A qualifier assigned to a provisional term within a language
        ##									planning or descriptive terminology environment. The content of
        ##									the termNote element when it has a type
        ##									attribute value of language-planningQualifier shall
        ##									be one of: recommendedTerm,
        ##									nonstandardizedTerm, proposedTerm, or
        ##										newTerm.
        "language-planningQualifier"
      | 
        ##  (lionHotkey) The letter in a word that acts as a hotkey in a computer
        ##									application. A hotkey is a key or a combination of keys
        ##									on a computer keyboard
        ##									that, when pressed at one time, performs a task (such as
        ##									starting an application) as an alternative to using a mouse or
        ##									other input device. Hotkeys are supported by many operating
        ##									systems and applications. The hotkey is indicated by an
        ##									ampersand in the term in software interface files, and by an
        ##									underscore in the actual visual display. The element content
        ##									shall be expressed in plainText. 
        "lionHotkey"
      | 
        ##  (normativeAuthorization) A term status qualifier assigned by an authoritative body,
        ##									such as a standards body or a governmental entity with a
        ##									regulatory function. The content of the termNote
        ##									element when it has a type attribute value of
        ##										normativeAuthorization shall be one of:
        ##										                              * standardizedTerm
        ##										                              * preferredTerm
        ##										                              * admittedTerm
        ##										                              * deprecatedTerm
        ##										                              * supersededTerm
        ##										                              * legalTerm
        ##										                              * regulatedTerm
        ##									                            The name of the authoritative body should be documented
        ##									in the terminology repository, and referenced in the TBX
        ##									document instance by using a refObject. 
        "normativeAuthorization"
      | 
        ##  (partOfSpeech) A category assigned to a word based on its grammatical and
        ##									semantic properties. For example: noun,
        ##									verb, or adjective. The element content
        ##									shall be expressed in plainText, and preferably be limited to a
        ##									set of picklist values. Only one value shall be permitted for
        ##									each term in a given entry. For example, the following
        ##									values are permitted in the TBX-Basic TML:
        ##										                              * noun
        ##										                              * verb
        ##										                              * adjective
        ##										                              * adverb
        ##										                              * properNoun
        ##										                              * other
        ##									                           
        ##                                  
        "partOfSpeech"
      | 
        ##  (processStatus) The status of a term with respect to its advancement within
        ##									the  terminology management process. The
        ##									content of the termNote element when it has a
        ##									type attribute value of processStatus
        ##									shall be one of: unprocessed,
        ##										provisionallyProcessed, or
        ##								finalized.
        "processStatus"
      | 
        ##  (pronunciation) The representation of the manner by which a term is spoken. In
        ##									TBX, pronunciation shall be represented in the International
        ##									Phonetic Alphabet. A given term can have more than one
        ##									pronunciation depending on the geographical area in which the
        ##									term is used. A given term can have more than one pronunciation
        ##									depending on the geographical area in which the term is used. In
        ##									this case use a separate tig or ntig element
        ##									for each pronunciation, and indicate the gegraphical area of
        ##									each by using a termNote element with a type
        ##									attribute value of geographicalUsage. The element
        ##									content shall be expressed in basicText.
        "pronunciation"
      | 
        ##  (proprietaryRestriction) A restriction placed on a term for the purpose of protecting
        ##									the right of an organization to the exclusive use of the term.
        ##									The content of the termNote element when it has a
        ##										type attribute value of
        ##										proprietaryRestriction shall be one of:
        ##										trademark, serviceMark or
        ##										tradeName. The content value "copyright" is
        ##										not included because copyright only applies to larger text
        ##										units, such as books, not to terms.
        ##                                  
        "proprietaryRestriction"
      | 
        ##  (register) Classification indicating the level of language assigned to a
        ##									term. The content of the termNote element when it has a
        ##										type attribute value of register shall
        ##									be one of: 
        ##										                              * colloquialRegister
        ##										                              * neutralRegister
        ##										                              * technicalRegister
        ##										                              * in-houseRegister
        ##										                              * bench-levelRegister
        ##										                              * slangRegister
        ##										                              * vulgarRegister
        ##									                           
        ##									                        
        "register"
      | 
        ##  (shortFormFor) A linking element used to identify a relation between the
        ##									subject term when it is a short form, and its full or expanded
        ##									form. It may be coupled with a target attribute to
        ##									point to the full or expanded form. Normally both the short form
        ##									and the full form will be contained in the same entry, but each
        ##									in its own tig, because they represent the same
        ##									concept. For example, the term United States could
        ##									have the following markup to point to the full form term
        ##										United States of America: United States of
        ##										America. The content of the element
        ##									would be the target term, expressed in basicText, which allows
        ##									the user to see the target term without going to its location in
        ##									the entry. The identification of a relation between a short form
        ##									and its full form indicates which term in a terminological entry
        ##									is the full form of the short form.
        ##									
        "shortFormFor"
      | 
        ##  (temporalQualifier) A property of a term with respect to its use over time. The
        ##									content of the termNote element when it has a
        ##									type attribute value of temporalQualifier
        ##									shall be one of: archaicTerm,
        ##									outdatedTerm, obsoleteTerm.
        "temporalQualifier"
      | 
        ##  (termLocation) A location in a document, computer file, or other information
        ##									medium, where the term frequently occurs, such as a user
        ##									interface object (in software), a packaging element, a component
        ##									in an industrial process, and so forth. The element content
        ##									shall be expressed in plainText, and preferably be restricted to
        ##									a set of picklist values. The following picklist values are
        ##									recommended for software user interface locations in a Windows
        ##									environment. 
        ##										                              * checkBox
        ##										                              * comboBox
        ##										                              * comboBoxElement
        ##										                              * dialogBox
        ##										                              * groupBox
        ##										                              * informativeMessage
        ##										                              * interactiveMessage
        ##										                              * menuItem
        ##										                              * progressBar
        ##										                              * pushButton
        ##										                              * radioButton
        ##										                              * slider
        ##										                              * spinBox
        ##										                              * tab
        ##										                              * tableText
        ##										                              * textBox
        ##										                              * toolTip
        ##										                              * user-definedType
        ##									                           
        ##								                         
        "termLocation"
      | 
        ##  (termProvenance) Classification of a term according to the methodology employed
        ##									in creating the term. The content of the termNote
        ##									element when it has a type attribute value of
        ##										termProvenance shall be one of:
        ##										transdisciplinaryBorrowing,
        ##										translingualBorrowing,
        ##									loanTranslation, or neologism.
        "termProvenance"
      | 
        ##  (termStructure) The structure of the components of a term, indicated using
        ##									square brackets. For example, e.g. : [bank statement] [total]
        ##									versus [bank] [statement total]. The element content shall be
        ##									expressed in plainText.
        ##									
        "termStructure"
      | 
        ##  (termType) A categorization of a term with respect to formal
        ##									representations of terms or where or how they are used, for
        ##									example, acronym. The content of the
        ##									termNote element when it has a type
        ##									attribute value of termType shall be one of the following:
        ##										                              * abbreviation
        ##										                              * acronym
        ##										                              * clippedTerm
        ##										                              * commonName
        ##										                              * entryTerm
        ##										                              * equation
        ##										                              * formula
        ##										                              * fullForm
        ##										                              * initialism
        ##										                              * internationalism
        ##										                              * internationalScientificTerm
        ##										                              * logicalExpression
        ##										                              * partNumber
        ##										                              * phraseologicalUnit
        ##										                              * transcribedForm
        ##										                              * transliteratedForm
        ##										                              * shortForm
        ##										                              * shortcut
        ##										                              * sku
        ##										                              * standardText
        ##										                              * string
        ##										                              * symbol
        ##										                              * synonym
        ##										                              * synonymousPhrase
        ##										                              * variant
        ##									                           Refer to ISO 12620 for definitions of the above term
        ##									types. The value shortcut refers to a string that
        ##									acts as a keyboard shortcut on computers, for example,
        ##										Ctrl + V is a term that represents a keyboard
        ##									shortcut for the concept of paste.
        "termType"
      | 
        ##  (timeRestriction) The indication of a period of time during or since which a
        ##									term was or has been subject to specified usage. For example,
        ##									several European countries have redefined the requirements for
        ##									certain university degrees in recent years. If, for instance,
        ##									the requirements for a baccalaureate degree changed from three
        ##									to four years in 1993, then any terminology entry defining the
        ##									term used to designate this degree would have to specify the
        ##									time restriction affecting the definition, which would be
        ##									different before 1993 and after 1993. The element content shall
        ##									be expressed in plainText. 
        "timeRestriction"
      | 
        ##  (transferComment) Note included in a term entry providing information on the
        ##									degree of equivalence, directionality or other special features
        ##									affecting equivalence between a term in one language and another
        ##									term in a second language. This element can be used in
        ##									conjunction with the 
        ##									element to indicate the preferred translation of the term in
        ##									question. The termNote element with a type
        ##									attribute value of transferComment can also have a
        ##										target attribute to point to the term that is the
        ##									object of the transfer comment.
        "transferComment"
      | 
        ##  (usageNote) A note containing information on the usage of the term.
        "usageNote"
    },
    empty
  }
start = TEI
